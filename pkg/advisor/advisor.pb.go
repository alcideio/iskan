// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: advisor.proto

/*
	Package advisor is a generated protocol buffer package.

	It is generated from these files:
		advisor.proto
		advisor_executions_state.proto
		advisor_job_profile.proto
		advisor_jobs.proto
		external_scanner.proto

	It has these top-level messages:
		AdvisorCheckFeatureBool
		AdvisorCheckFeatureStringSet
		AdvisorHostPathRule
		AdvisorCheckFeatureAlcideRules
		AdvisorCheckConfigItem
		AdvisorConfigDescriptor
		AdvisorModuleItem
		AdvisorResourceCheck
		AdvisorResourceCheckGroup
		AdvisorCheckModule
		AdvisorPolicyScope
		AdvisorValidationProfile
		AdvisorTestConfig
		AdvisorProfileDef
		AdvisorValidationPolicySpec
		CheckResult
		ResourceInfo
		CheckInfo
		AdditionalFinding
		AdditionalFindings
		AdvisorReportHeader
		AdvisorReportData
		AdvisorReport
		AdvisorClusterReport
		AdvisorClusterDiffReport
		AdvisorExecutionsState
		AdvisorExecution
		AdvisorJobProfile
		AdvisorJobs
		AdvisorJob
		AdvisorImageScannerArgs
		AdvisorImageScannerConfig
		VulnInfo
		AdvisorExternalScanners
*/
package advisor

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Platform int32

const (
	Platform_Kubernetes Platform = 0
	Platform_Istio      Platform = 1
)

var Platform_name = map[int32]string{
	0: "Kubernetes",
	1: "Istio",
}
var Platform_value = map[string]int32{
	"Kubernetes": 0,
	"Istio":      1,
}

func (x Platform) String() string {
	return proto.EnumName(Platform_name, int32(x))
}
func (Platform) EnumDescriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{0} }

type CheckId int32

const (
	CheckId_UnspecifiedCheckId           CheckId = 0
	CheckId_ContainerCheckBase           CheckId = 100
	CheckId_ContainerCheckPriviliged     CheckId = 101
	CheckId_ContainerCheckRunAsRoot      CheckId = 102
	CheckId_ContainerCheckReadOnlyRootFS CheckId = 103
	CheckId_ContainerCheckImageTag       CheckId = 110
	CheckId_ContainerPrivateCredntials   CheckId = 120
	CheckId_ContainerCheckImageWhiteList CheckId = 111
	CheckId_PodCheckHostNetwork          CheckId = 200
	CheckId_PodCheckHostPID              CheckId = 201
	CheckId_PodCheckHostIPC              CheckId = 202
	CheckId_PodAllowedHostPaths          CheckId = 203
	CheckId_PodForbiddenHostPaths        CheckId = 204
	CheckId_PodCheckAnnotations          CheckId = 205
	CheckId_PodCheckLabels               CheckId = 206
	CheckId_WorkloadEmbeddedPolicy       CheckId = 300
	CheckId_WorkloadEmbeddedPolicyRules  CheckId = 301
	CheckId_ApiServerSecretReadAccess    CheckId = 500
	CheckId_ApiServerPodCreateAccess     CheckId = 501
	CheckId_PodNetworkPolicy             CheckId = 600
	CheckId_ConfigMapsPrivateCredntials  CheckId = 700
	CheckId_IngressCheckTlsEnabled       CheckId = 900
)

var CheckId_name = map[int32]string{
	0:   "UnspecifiedCheckId",
	100: "ContainerCheckBase",
	101: "ContainerCheckPriviliged",
	102: "ContainerCheckRunAsRoot",
	103: "ContainerCheckReadOnlyRootFS",
	110: "ContainerCheckImageTag",
	120: "ContainerPrivateCredntials",
	111: "ContainerCheckImageWhiteList",
	200: "PodCheckHostNetwork",
	201: "PodCheckHostPID",
	202: "PodCheckHostIPC",
	203: "PodAllowedHostPaths",
	204: "PodForbiddenHostPaths",
	205: "PodCheckAnnotations",
	206: "PodCheckLabels",
	300: "WorkloadEmbeddedPolicy",
	301: "WorkloadEmbeddedPolicyRules",
	500: "ApiServerSecretReadAccess",
	501: "ApiServerPodCreateAccess",
	600: "PodNetworkPolicy",
	700: "ConfigMapsPrivateCredntials",
	900: "IngressCheckTlsEnabled",
}
var CheckId_value = map[string]int32{
	"UnspecifiedCheckId":           0,
	"ContainerCheckBase":           100,
	"ContainerCheckPriviliged":     101,
	"ContainerCheckRunAsRoot":      102,
	"ContainerCheckReadOnlyRootFS": 103,
	"ContainerCheckImageTag":       110,
	"ContainerPrivateCredntials":   120,
	"ContainerCheckImageWhiteList": 111,
	"PodCheckHostNetwork":          200,
	"PodCheckHostPID":              201,
	"PodCheckHostIPC":              202,
	"PodAllowedHostPaths":          203,
	"PodForbiddenHostPaths":        204,
	"PodCheckAnnotations":          205,
	"PodCheckLabels":               206,
	"WorkloadEmbeddedPolicy":       300,
	"WorkloadEmbeddedPolicyRules":  301,
	"ApiServerSecretReadAccess":    500,
	"ApiServerPodCreateAccess":     501,
	"PodNetworkPolicy":             600,
	"ConfigMapsPrivateCredntials":  700,
	"IngressCheckTlsEnabled":       900,
}

func (x CheckId) String() string {
	return proto.EnumName(CheckId_name, int32(x))
}
func (CheckId) EnumDescriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{1} }

type CheckSeverity int32

const (
	CheckSeverity_UnspecifiedSeverity CheckSeverity = 0
	CheckSeverity_Pass                CheckSeverity = 1
	CheckSeverity_Low                 CheckSeverity = 2
	CheckSeverity_Medium              CheckSeverity = 3
	CheckSeverity_High                CheckSeverity = 4
	CheckSeverity_Critical            CheckSeverity = 5
)

var CheckSeverity_name = map[int32]string{
	0: "UnspecifiedSeverity",
	1: "Pass",
	2: "Low",
	3: "Medium",
	4: "High",
	5: "Critical",
}
var CheckSeverity_value = map[string]int32{
	"UnspecifiedSeverity": 0,
	"Pass":                1,
	"Low":                 2,
	"Medium":              3,
	"High":                4,
	"Critical":            5,
}

func (x CheckSeverity) String() string {
	return proto.EnumName(CheckSeverity_name, int32(x))
}
func (CheckSeverity) EnumDescriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{2} }

type AdmissionAction int32

const (
	AdmissionAction_UnspecifiedAction AdmissionAction = 0
	// Alert Only and Allow admission
	AdmissionAction_Alert AdmissionAction = 1
	// Alert and Deny admission
	AdmissionAction_Deny AdmissionAction = 2
	// Allow (no Alert)
	AdmissionAction_Allow AdmissionAction = 3
)

var AdmissionAction_name = map[int32]string{
	0: "UnspecifiedAction",
	1: "Alert",
	2: "Deny",
	3: "Allow",
}
var AdmissionAction_value = map[string]int32{
	"UnspecifiedAction": 0,
	"Alert":             1,
	"Deny":              2,
	"Allow":             3,
}

func (x AdmissionAction) String() string {
	return proto.EnumName(AdmissionAction_name, int32(x))
}
func (AdmissionAction) EnumDescriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{3} }

type CheckCategory int32

const (
	CheckCategory_UnspecifiedCategory            CheckCategory = 0
	CheckCategory_ContainerSecurityContextChecks CheckCategory = 1
	CheckCategory_PodSecurityChecks              CheckCategory = 2
	CheckCategory_ContainerImageChecks           CheckCategory = 3
	CheckCategory_ResourceConformanceChecks      CheckCategory = 4
	CheckCategory_ResourcePriviligedApiAccess    CheckCategory = 5
	CheckCategory_PodNetworkSecurity             CheckCategory = 6
	CheckCategory_CISKubeBenchmarkWorkerNode     CheckCategory = 7
	CheckCategory_CrdCustomChecks                CheckCategory = 8
	CheckCategory_IngressControllerChecks        CheckCategory = 9
	CheckCategory_IstioControlPlaneChecks        CheckCategory = 10
)

var CheckCategory_name = map[int32]string{
	0:  "UnspecifiedCategory",
	1:  "ContainerSecurityContextChecks",
	2:  "PodSecurityChecks",
	3:  "ContainerImageChecks",
	4:  "ResourceConformanceChecks",
	5:  "ResourcePriviligedApiAccess",
	6:  "PodNetworkSecurity",
	7:  "CISKubeBenchmarkWorkerNode",
	8:  "CrdCustomChecks",
	9:  "IngressControllerChecks",
	10: "IstioControlPlaneChecks",
}
var CheckCategory_value = map[string]int32{
	"UnspecifiedCategory":            0,
	"ContainerSecurityContextChecks": 1,
	"PodSecurityChecks":              2,
	"ContainerImageChecks":           3,
	"ResourceConformanceChecks":      4,
	"ResourcePriviligedApiAccess":    5,
	"PodNetworkSecurity":             6,
	"CISKubeBenchmarkWorkerNode":     7,
	"CrdCustomChecks":                8,
	"IngressControllerChecks":        9,
	"IstioControlPlaneChecks":        10,
}

func (x CheckCategory) String() string {
	return proto.EnumName(CheckCategory_name, int32(x))
}
func (CheckCategory) EnumDescriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{4} }

type CheckApplicabilityType int32

const (
	CheckApplicabilityType_Admission CheckApplicabilityType = 0
)

var CheckApplicabilityType_name = map[int32]string{
	0: "Admission",
}
var CheckApplicabilityType_value = map[string]int32{
	"Admission": 0,
}

func (x CheckApplicabilityType) String() string {
	return proto.EnumName(CheckApplicabilityType_name, int32(x))
}
func (CheckApplicabilityType) EnumDescriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{5} }

type ConfigItemType int32

const (
	ConfigItemType_String           ConfigItemType = 0
	ConfigItemType_Regex            ConfigItemType = 1
	ConfigItemType_ImageRegistryURL ConfigItemType = 2
)

var ConfigItemType_name = map[int32]string{
	0: "String",
	1: "Regex",
	2: "ImageRegistryURL",
}
var ConfigItemType_value = map[string]int32{
	"String":           0,
	"Regex":            1,
	"ImageRegistryURL": 2,
}

func (x ConfigItemType) String() string {
	return proto.EnumName(ConfigItemType_name, int32(x))
}
func (ConfigItemType) EnumDescriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{6} }

type PricePlanType int32

const (
	PricePlanType_Free    PricePlanType = 0
	PricePlanType_Starter PricePlanType = 1
	PricePlanType_Pro     PricePlanType = 2
)

var PricePlanType_name = map[int32]string{
	0: "Free",
	1: "Starter",
	2: "Pro",
}
var PricePlanType_value = map[string]int32{
	"Free":    0,
	"Starter": 1,
	"Pro":     2,
}

func (x PricePlanType) String() string {
	return proto.EnumName(PricePlanType_name, int32(x))
}
func (PricePlanType) EnumDescriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{7} }

type DeltaOp int32

const (
	DeltaOp_Unmodified DeltaOp = 0
	// Alert Only and Allow admission
	DeltaOp_Modified DeltaOp = 1
	// Alert and Deny admission
	DeltaOp_Added DeltaOp = 2
	// Allow (no Alert)
	DeltaOp_Deleted DeltaOp = 3
)

var DeltaOp_name = map[int32]string{
	0: "Unmodified",
	1: "Modified",
	2: "Added",
	3: "Deleted",
}
var DeltaOp_value = map[string]int32{
	"Unmodified": 0,
	"Modified":   1,
	"Added":      2,
	"Deleted":    3,
}

func (x DeltaOp) String() string {
	return proto.EnumName(DeltaOp_name, int32(x))
}
func (DeltaOp) EnumDescriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{8} }

type AdvisorCheckFeatureBool struct {
	Action             string            `protobuf:"bytes,1,opt,name=Action,proto3" json:"Action,omitempty" default:"alert" validate:"required,eq=alert | eq=deny | eq=allow" doc:"Admission action"`
	AlertTags          map[string]string `protobuf:"bytes,2,rep,name=AlertTags" json:"AlertTags,omitempty" doc:"tags attached to alerts emitted by the policy checks" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	OverrideAnnotation string            `protobuf:"bytes,3,opt,name=OverrideAnnotation,proto3" json:"OverrideAnnotation,omitempty" default:"" doc:"if annotation of the form exist advisor.policy.alcide.io/<feature-name>, skip validation"`
	Expected           bool              `protobuf:"varint,4,opt,name=Expected,proto3" json:"Expected" doc:"For boolean checks, express the expected value"`
	SkipResource       []string          `protobuf:"bytes,5,rep,name=SkipResource" json:"SkipResource,omitempty" doc:"Specify list of resources to skip this check. Each item should follow resource-kind/namespace/name "`
	Severity           string            `protobuf:"bytes,6,opt,name=Severity,proto3" json:"Severity,omitempty" default:"High" validate:"required,eq=Critical | eq=High | eq=Medium | eq=Low | eq=Pass" doc:"Check Severity"`
}

func (m *AdvisorCheckFeatureBool) Reset()                    { *m = AdvisorCheckFeatureBool{} }
func (m *AdvisorCheckFeatureBool) String() string            { return proto.CompactTextString(m) }
func (*AdvisorCheckFeatureBool) ProtoMessage()               {}
func (*AdvisorCheckFeatureBool) Descriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{0} }

func (m *AdvisorCheckFeatureBool) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *AdvisorCheckFeatureBool) GetAlertTags() map[string]string {
	if m != nil {
		return m.AlertTags
	}
	return nil
}

func (m *AdvisorCheckFeatureBool) GetOverrideAnnotation() string {
	if m != nil {
		return m.OverrideAnnotation
	}
	return ""
}

func (m *AdvisorCheckFeatureBool) GetExpected() bool {
	if m != nil {
		return m.Expected
	}
	return false
}

func (m *AdvisorCheckFeatureBool) GetSkipResource() []string {
	if m != nil {
		return m.SkipResource
	}
	return nil
}

func (m *AdvisorCheckFeatureBool) GetSeverity() string {
	if m != nil {
		return m.Severity
	}
	return ""
}

type AdvisorCheckFeatureStringSet struct {
	Action             string            `protobuf:"bytes,1,opt,name=Action,proto3" json:"Action,omitempty" default:"alert" validate:"required,eq=alert | eq=deny | eq=allow" doc:"Admission action"`
	AlertTags          map[string]string `protobuf:"bytes,2,rep,name=AlertTags" json:"AlertTags,omitempty" doc:"tags attached to alerts emitted by the policy checks" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	OverrideAnnotation string            `protobuf:"bytes,3,opt,name=OverrideAnnotation,proto3" json:"OverrideAnnotation,omitempty" default:"" doc:"if annotation of the form exist advisor.policy.alcide.io/<feature-name>, skip validation"`
	Expected           []string          `protobuf:"bytes,4,rep,name=Expected" json:"Expected" doc:"For boolean checks, express the expected value"`
	SkipResource       []string          `protobuf:"bytes,5,rep,name=SkipResource" json:"SkipResource,omitempty" doc:"Specify list of resources to skip this check. Each item should follow resource-kind/namespace/name "`
	Severity           string            `protobuf:"bytes,6,opt,name=Severity,proto3" json:"Severity,omitempty" default:"High" validate:"required,eq=Critical | eq=High | eq=Medium | eq=Low | eq=Pass" doc:"Check Severity"`
}

func (m *AdvisorCheckFeatureStringSet) Reset()         { *m = AdvisorCheckFeatureStringSet{} }
func (m *AdvisorCheckFeatureStringSet) String() string { return proto.CompactTextString(m) }
func (*AdvisorCheckFeatureStringSet) ProtoMessage()    {}
func (*AdvisorCheckFeatureStringSet) Descriptor() ([]byte, []int) {
	return fileDescriptorAdvisor, []int{1}
}

func (m *AdvisorCheckFeatureStringSet) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *AdvisorCheckFeatureStringSet) GetAlertTags() map[string]string {
	if m != nil {
		return m.AlertTags
	}
	return nil
}

func (m *AdvisorCheckFeatureStringSet) GetOverrideAnnotation() string {
	if m != nil {
		return m.OverrideAnnotation
	}
	return ""
}

func (m *AdvisorCheckFeatureStringSet) GetExpected() []string {
	if m != nil {
		return m.Expected
	}
	return nil
}

func (m *AdvisorCheckFeatureStringSet) GetSkipResource() []string {
	if m != nil {
		return m.SkipResource
	}
	return nil
}

func (m *AdvisorCheckFeatureStringSet) GetSeverity() string {
	if m != nil {
		return m.Severity
	}
	return ""
}

type AdvisorHostPathRule struct {
	Path     string `protobuf:"bytes,1,opt,name=Path,proto3" json:"Path,omitempty" default:"" validate:"required,eq=alert | eq=deny | eq=allow" doc:"Admission action"`
	ReadOnly bool   `protobuf:"varint,2,opt,name=ReadOnly,proto3" json:"ReadOnly,omitempty" doc:"For boolean checks, express the expected value"`
}

func (m *AdvisorHostPathRule) Reset()                    { *m = AdvisorHostPathRule{} }
func (m *AdvisorHostPathRule) String() string            { return proto.CompactTextString(m) }
func (*AdvisorHostPathRule) ProtoMessage()               {}
func (*AdvisorHostPathRule) Descriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{2} }

func (m *AdvisorHostPathRule) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *AdvisorHostPathRule) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

type AdvisorCheckFeatureAlcideRules struct {
	Action             string            `protobuf:"bytes,1,opt,name=Action,proto3" json:"Action,omitempty" default:"alert" validate:"required,eq=alert | eq=deny | eq=allow" doc:"Admission action"`
	AlertTags          map[string]string `protobuf:"bytes,2,rep,name=AlertTags" json:"AlertTags,omitempty" doc:"tags attached to alerts emitted by the policy checks" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	OverrideAnnotation string            `protobuf:"bytes,3,opt,name=OverrideAnnotation,proto3" json:"OverrideAnnotation,omitempty" default:"" doc:"if annotation of the form exist advisor.policy.alcide.io/<feature-name>, skip validation"`
	ExpectedInbound    []string          `protobuf:"bytes,4,rep,name=ExpectedInbound" json:"ExpectedInbound" doc:"For boolean checks, express the expected value"`
	ExpectedOutbound   []string          `protobuf:"bytes,5,rep,name=ExpectedOutbound" json:"ExpectedOutbound" doc:"For boolean checks, express the expected value"`
	SkipResource       []string          `protobuf:"bytes,6,rep,name=SkipResource" json:"SkipResource,omitempty" doc:"Specify list of resources to skip this check. Each item should follow resource-kind/namespace/name "`
	Severity           string            `protobuf:"bytes,7,opt,name=Severity,proto3" json:"Severity,omitempty" default:"High" validate:"required,eq=Critical | eq=High | eq=Medium | eq=Low | eq=Pass" doc:"Check Severity"`
}

func (m *AdvisorCheckFeatureAlcideRules) Reset()         { *m = AdvisorCheckFeatureAlcideRules{} }
func (m *AdvisorCheckFeatureAlcideRules) String() string { return proto.CompactTextString(m) }
func (*AdvisorCheckFeatureAlcideRules) ProtoMessage()    {}
func (*AdvisorCheckFeatureAlcideRules) Descriptor() ([]byte, []int) {
	return fileDescriptorAdvisor, []int{3}
}

func (m *AdvisorCheckFeatureAlcideRules) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *AdvisorCheckFeatureAlcideRules) GetAlertTags() map[string]string {
	if m != nil {
		return m.AlertTags
	}
	return nil
}

func (m *AdvisorCheckFeatureAlcideRules) GetOverrideAnnotation() string {
	if m != nil {
		return m.OverrideAnnotation
	}
	return ""
}

func (m *AdvisorCheckFeatureAlcideRules) GetExpectedInbound() []string {
	if m != nil {
		return m.ExpectedInbound
	}
	return nil
}

func (m *AdvisorCheckFeatureAlcideRules) GetExpectedOutbound() []string {
	if m != nil {
		return m.ExpectedOutbound
	}
	return nil
}

func (m *AdvisorCheckFeatureAlcideRules) GetSkipResource() []string {
	if m != nil {
		return m.SkipResource
	}
	return nil
}

func (m *AdvisorCheckFeatureAlcideRules) GetSeverity() string {
	if m != nil {
		return m.Severity
	}
	return ""
}

type AdvisorCheckConfigItem struct {
	Description string `protobuf:"bytes,1,opt,name=Description,proto3" json:"Description,omitempty" default:"" doc:"Description"`
	Item        string `protobuf:"bytes,2,opt,name=Item,proto3" json:"Item,omitempty" default:"" doc:"Configuration Item"`
}

func (m *AdvisorCheckConfigItem) Reset()                    { *m = AdvisorCheckConfigItem{} }
func (m *AdvisorCheckConfigItem) String() string            { return proto.CompactTextString(m) }
func (*AdvisorCheckConfigItem) ProtoMessage()               {}
func (*AdvisorCheckConfigItem) Descriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{4} }

func (m *AdvisorCheckConfigItem) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *AdvisorCheckConfigItem) GetItem() string {
	if m != nil {
		return m.Item
	}
	return ""
}

type AdvisorConfigDescriptor struct {
	Title       string `protobuf:"bytes,1,opt,name=Title,proto3" json:"Title,omitempty" default:"Properties Configuration" doc:"Config Items title"`
	Value       string `protobuf:"bytes,2,opt,name=Value,proto3" json:"Value,omitempty" default:"Property" doc:"Config Items value text"`
	Placeholder string `protobuf:"bytes,3,opt,name=Placeholder,proto3" json:"Placeholder,omitempty" default:"Enter the property to configure" doc:"Config Items placeholder"`
	Type        string `protobuf:"bytes,4,opt,name=Type,proto3" json:"Type,omitempty" default:"" validate:"optional,eq=String | eq=Integer | eq=ImageRegistryURL | eq=Regex | eq=KubeResource " doc:"Type Validator"`
}

func (m *AdvisorConfigDescriptor) Reset()                    { *m = AdvisorConfigDescriptor{} }
func (m *AdvisorConfigDescriptor) String() string            { return proto.CompactTextString(m) }
func (*AdvisorConfigDescriptor) ProtoMessage()               {}
func (*AdvisorConfigDescriptor) Descriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{5} }

func (m *AdvisorConfigDescriptor) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *AdvisorConfigDescriptor) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *AdvisorConfigDescriptor) GetPlaceholder() string {
	if m != nil {
		return m.Placeholder
	}
	return ""
}

func (m *AdvisorConfigDescriptor) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type AdvisorModuleItem struct {
	Description string `protobuf:"bytes,1,opt,name=Description,proto3" json:"Description,omitempty" default:"" doc:"Description"`
	Item        string `protobuf:"bytes,2,opt,name=Item,proto3" json:"Item,omitempty" default:"" doc:"Admission action"`
}

func (m *AdvisorModuleItem) Reset()                    { *m = AdvisorModuleItem{} }
func (m *AdvisorModuleItem) String() string            { return proto.CompactTextString(m) }
func (*AdvisorModuleItem) ProtoMessage()               {}
func (*AdvisorModuleItem) Descriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{6} }

func (m *AdvisorModuleItem) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *AdvisorModuleItem) GetItem() string {
	if m != nil {
		return m.Item
	}
	return ""
}

//
// Generic Cluster Resource Check
//
type AdvisorResourceCheck struct {
	// Check Id
	ID string `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	// Check Category
	Title    string `protobuf:"bytes,2,opt,name=Title,proto3" json:"Title,omitempty"`
	Action   string `protobuf:"bytes,3,opt,name=Action,proto3" json:"Action,omitempty" default:"alert" validate:"required,eq=alert | eq=deny | eq=allow" doc:"Admission action"`
	Severity string `protobuf:"bytes,4,opt,name=Severity,proto3" json:"Severity,omitempty" default:"High" validate:"required,eq=Critical | eq=High | eq=Medium | eq=Low | eq=Pass" doc:"Check Severity"`
	// A set of requirements that must be met
	// each requirement has the following format:
	// {{ KubeResource     ApiKind ApiGroup ApiVersion Namespace Name JmespathQuery}}
	// {{ KubeResourceList ApiKind ApiGroup ApiVersion Namespace      JmespathQuery}}
	Requirements []string `protobuf:"bytes,5,rep,name=Requirements" json:"Requirements,omitempty"`
	// Expected Value (true or false)
	Expected      string   `protobuf:"bytes,6,opt,name=Expected,proto3" json:"Expected,omitempty"`
	PreRequisites []string `protobuf:"bytes,7,rep,name=PreRequisites" json:"PreRequisites,omitempty"`
	// Advice itself
	Message string `protobuf:"bytes,9,opt,name=Message,proto3" json:"Message,omitempty"`
	// Recommendation
	Recommendation string `protobuf:"bytes,10,opt,name=Recommendation,proto3" json:"Recommendation,omitempty"`
	// Urls for more info
	References           []string                 `protobuf:"bytes,11,rep,name=References" json:"References,omitempty"`
	OverrideAnnotation   string                   `protobuf:"bytes,12,opt,name=OverrideAnnotation,proto3" json:"OverrideAnnotation,omitempty" default:"" doc:"if annotation of the form exist advisor.policy.alcide.io/<feature-name>, skip validation"`
	SkipResource         []string                 `protobuf:"bytes,13,rep,name=SkipResource" json:"SkipResource,omitempty" doc:"Specify list of resources to skip this check. Each item should follow resource-kind/namespace/name "`
	Config               []AdvisorCheckConfigItem `protobuf:"bytes,14,rep,name=Config" json:"Items" doc:"Check Specific Configuration"`
	MandatoryConfigItems bool                     `protobuf:"varint,15,opt,name=MandatoryConfigItems,proto3" json:"MandatoryConfigItems,omitempty" default:"false" doc:"Controls whether the config items are mandatory"`
	ConfigDescriptor     *AdvisorConfigDescriptor `protobuf:"bytes,16,opt,name=ConfigDescriptor" json:"ConfigDescriptor,omitempty"`
	Description          string                   `protobuf:"bytes,17,opt,name=Description,proto3" json:"Description,omitempty"`
	CheckApplicability   []CheckApplicabilityType `protobuf:"varint,18,rep,packed,name=CheckApplicability,enum=advisor.CheckApplicabilityType" json:"CheckApplicability,omitempty" doc:"Specify list of check applicability types."`
}

func (m *AdvisorResourceCheck) Reset()                    { *m = AdvisorResourceCheck{} }
func (m *AdvisorResourceCheck) String() string            { return proto.CompactTextString(m) }
func (*AdvisorResourceCheck) ProtoMessage()               {}
func (*AdvisorResourceCheck) Descriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{7} }

func (m *AdvisorResourceCheck) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *AdvisorResourceCheck) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *AdvisorResourceCheck) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *AdvisorResourceCheck) GetSeverity() string {
	if m != nil {
		return m.Severity
	}
	return ""
}

func (m *AdvisorResourceCheck) GetRequirements() []string {
	if m != nil {
		return m.Requirements
	}
	return nil
}

func (m *AdvisorResourceCheck) GetExpected() string {
	if m != nil {
		return m.Expected
	}
	return ""
}

func (m *AdvisorResourceCheck) GetPreRequisites() []string {
	if m != nil {
		return m.PreRequisites
	}
	return nil
}

func (m *AdvisorResourceCheck) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *AdvisorResourceCheck) GetRecommendation() string {
	if m != nil {
		return m.Recommendation
	}
	return ""
}

func (m *AdvisorResourceCheck) GetReferences() []string {
	if m != nil {
		return m.References
	}
	return nil
}

func (m *AdvisorResourceCheck) GetOverrideAnnotation() string {
	if m != nil {
		return m.OverrideAnnotation
	}
	return ""
}

func (m *AdvisorResourceCheck) GetSkipResource() []string {
	if m != nil {
		return m.SkipResource
	}
	return nil
}

func (m *AdvisorResourceCheck) GetConfig() []AdvisorCheckConfigItem {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *AdvisorResourceCheck) GetMandatoryConfigItems() bool {
	if m != nil {
		return m.MandatoryConfigItems
	}
	return false
}

func (m *AdvisorResourceCheck) GetConfigDescriptor() *AdvisorConfigDescriptor {
	if m != nil {
		return m.ConfigDescriptor
	}
	return nil
}

func (m *AdvisorResourceCheck) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *AdvisorResourceCheck) GetCheckApplicability() []CheckApplicabilityType {
	if m != nil {
		return m.CheckApplicability
	}
	return nil
}

type AdvisorResourceCheckGroup struct {
	// Check Id
	GroupID string `protobuf:"bytes,1,opt,name=GroupID,proto3" json:"GroupID,omitempty"`
	// Check Category
	Title string `protobuf:"bytes,2,opt,name=Title,proto3" json:"Title,omitempty"`
	// {{ KubeResourceList ApiGroup ApiKind Namespace }}
	ResourceSelector string                 `protobuf:"bytes,3,opt,name=ResourceSelector,proto3" json:"ResourceSelector,omitempty"`
	SkipResource     []string               `protobuf:"bytes,4,rep,name=SkipResource" json:"SkipResource,omitempty" doc:"Specify list of resources to skip this check. Each item should follow resource-kind/namespace/name "`
	Checks           []AdvisorResourceCheck `protobuf:"bytes,6,rep,name=Checks" json:"Checks"`
}

func (m *AdvisorResourceCheckGroup) Reset()                    { *m = AdvisorResourceCheckGroup{} }
func (m *AdvisorResourceCheckGroup) String() string            { return proto.CompactTextString(m) }
func (*AdvisorResourceCheckGroup) ProtoMessage()               {}
func (*AdvisorResourceCheckGroup) Descriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{8} }

func (m *AdvisorResourceCheckGroup) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

func (m *AdvisorResourceCheckGroup) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *AdvisorResourceCheckGroup) GetResourceSelector() string {
	if m != nil {
		return m.ResourceSelector
	}
	return ""
}

func (m *AdvisorResourceCheckGroup) GetSkipResource() []string {
	if m != nil {
		return m.SkipResource
	}
	return nil
}

func (m *AdvisorResourceCheckGroup) GetChecks() []AdvisorResourceCheck {
	if m != nil {
		return m.Checks
	}
	return nil
}

type AdvisorCheckModule struct {
	// Module Id
	ID string `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	// Check Category
	Type     string                      `protobuf:"bytes,2,opt,name=Type,proto3" json:"Type,omitempty"`
	Title    string                      `protobuf:"bytes,3,opt,name=Title,proto3" json:"Title,omitempty"`
	Platform string                      `protobuf:"bytes,4,opt,name=Platform,proto3" json:"Platform,omitempty" default:"Kubernetes" validate:"required,eq=Kubernetes | eq=Istio | eq=Knative" doc:"Platform"`
	Groups   []AdvisorResourceCheckGroup `protobuf:"bytes,5,rep,name=Groups" json:"Groups"`
	// A set of requirements to verify before running those checks
	// No PreRequisites - means module is applicable
	// each requirement has the following format:
	//  {{ IsCloudProvider aws }}
	//  {{ KubeResource     ApiKind ApiGroup ApiVersion Namespace Name JmespathQuery}}
	//  {{ KubeResourceList ApiKind ApiGroup ApiVersion Namespace      JmespathQuery}}
	PreRequisites []string `protobuf:"bytes,6,rep,name=PreRequisites" json:"PreRequisites,omitempty"`
	//
	// Add PASS checks to the report ... suitable for Benchmark checks
	//
	ReportPassedChecks bool                     `protobuf:"varint,7,opt,name=ReportPassedChecks,proto3" json:"ReportPassedChecks,omitempty"`
	Items              []AdvisorModuleItem      `protobuf:"bytes,8,rep,name=Items" json:"Items" doc:""`
	ConfigItems        []AdvisorCheckConfigItem `protobuf:"bytes,9,rep,name=ConfigItems" json:"ConfigItems" doc:"Check Global Configuration"`
}

func (m *AdvisorCheckModule) Reset()                    { *m = AdvisorCheckModule{} }
func (m *AdvisorCheckModule) String() string            { return proto.CompactTextString(m) }
func (*AdvisorCheckModule) ProtoMessage()               {}
func (*AdvisorCheckModule) Descriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{9} }

func (m *AdvisorCheckModule) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *AdvisorCheckModule) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AdvisorCheckModule) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *AdvisorCheckModule) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *AdvisorCheckModule) GetGroups() []AdvisorResourceCheckGroup {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *AdvisorCheckModule) GetPreRequisites() []string {
	if m != nil {
		return m.PreRequisites
	}
	return nil
}

func (m *AdvisorCheckModule) GetReportPassedChecks() bool {
	if m != nil {
		return m.ReportPassedChecks
	}
	return false
}

func (m *AdvisorCheckModule) GetItems() []AdvisorModuleItem {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *AdvisorCheckModule) GetConfigItems() []AdvisorCheckConfigItem {
	if m != nil {
		return m.ConfigItems
	}
	return nil
}

type AdvisorPolicyScope struct {
	NamespaceInclude string `protobuf:"bytes,1,opt,name=NamespaceInclude,proto3" json:"NamespaceInclude,omitempty" default:"*" doc:"Comma separated namespaces validation should be applied"`
	NamespaceExclude string `protobuf:"bytes,2,opt,name=NamespaceExclude,proto3" json:"NamespaceExclude,omitempty" default:""  doc:"Comma separated namespaces validation should be excluded"`
	Clusters         string `protobuf:"bytes,4,opt,name=Clusters,proto3" json:"Clusters,omitempty" default:"*" doc:"Comma separated cluster uids should be applied"`
	ClustersExclude  string `protobuf:"bytes,5,opt,name=ClustersExclude,proto3" json:"ClustersExclude,omitempty" default:"*" doc:"Comma separated cluster uids should be excluded"`
}

func (m *AdvisorPolicyScope) Reset()                    { *m = AdvisorPolicyScope{} }
func (m *AdvisorPolicyScope) String() string            { return proto.CompactTextString(m) }
func (*AdvisorPolicyScope) ProtoMessage()               {}
func (*AdvisorPolicyScope) Descriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{10} }

func (m *AdvisorPolicyScope) GetNamespaceInclude() string {
	if m != nil {
		return m.NamespaceInclude
	}
	return ""
}

func (m *AdvisorPolicyScope) GetNamespaceExclude() string {
	if m != nil {
		return m.NamespaceExclude
	}
	return ""
}

func (m *AdvisorPolicyScope) GetClusters() string {
	if m != nil {
		return m.Clusters
	}
	return ""
}

func (m *AdvisorPolicyScope) GetClustersExclude() string {
	if m != nil {
		return m.ClustersExclude
	}
	return ""
}

type AdvisorValidationProfile struct {
	Name        string        `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	UID         string        `protobuf:"bytes,2,opt,name=UID,proto3" json:"UID,omitempty"`
	Description string        `protobuf:"bytes,3,opt,name=Description,proto3" json:"Description,omitempty"`
	Version     string        `protobuf:"bytes,4,opt,name=Version,proto3" json:"Version,omitempty"`
	PricePlan   PricePlanType `protobuf:"varint,5,opt,name=PricePlan,proto3,enum=advisor.PricePlanType" json:"PricePlan,omitempty"`
	// This is the profile ID that is generated in the management server
	ProfileID         string                      `protobuf:"bytes,6,opt,name=ProfileID,proto3" json:"ProfileID,omitempty"`
	Scope             AdvisorPolicyScope          `protobuf:"bytes,10,opt,name=Scope" json:"Scope"`
	ApplyOnAdmission  bool                        `protobuf:"varint,11,opt,name=ApplyOnAdmission,proto3" json:"ApplyOnAdmission,omitempty" default:"true"  doc:"Policy should be applied on resource admission to the cluster"`
	ApplyOnScan       bool                        `protobuf:"varint,12,opt,name=ApplyOnScan,proto3" json:"ApplyOnScan,omitempty" default:"true"  doc:"Policy should be applied on cluster scan"`
	Policy            AdvisorValidationPolicySpec `protobuf:"bytes,13,opt,name=Policy" json:"Policy" default:"true"  doc:"Policy should be applied on cluster scan"`
	ProfileDefinition *AdvisorProfileDef          `protobuf:"bytes,20,opt,name=profileDefinition" json:"profileDefinition,omitempty"`
}

func (m *AdvisorValidationProfile) Reset()                    { *m = AdvisorValidationProfile{} }
func (m *AdvisorValidationProfile) String() string            { return proto.CompactTextString(m) }
func (*AdvisorValidationProfile) ProtoMessage()               {}
func (*AdvisorValidationProfile) Descriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{11} }

func (m *AdvisorValidationProfile) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AdvisorValidationProfile) GetUID() string {
	if m != nil {
		return m.UID
	}
	return ""
}

func (m *AdvisorValidationProfile) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *AdvisorValidationProfile) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *AdvisorValidationProfile) GetPricePlan() PricePlanType {
	if m != nil {
		return m.PricePlan
	}
	return PricePlanType_Free
}

func (m *AdvisorValidationProfile) GetProfileID() string {
	if m != nil {
		return m.ProfileID
	}
	return ""
}

func (m *AdvisorValidationProfile) GetScope() AdvisorPolicyScope {
	if m != nil {
		return m.Scope
	}
	return AdvisorPolicyScope{}
}

func (m *AdvisorValidationProfile) GetApplyOnAdmission() bool {
	if m != nil {
		return m.ApplyOnAdmission
	}
	return false
}

func (m *AdvisorValidationProfile) GetApplyOnScan() bool {
	if m != nil {
		return m.ApplyOnScan
	}
	return false
}

func (m *AdvisorValidationProfile) GetPolicy() AdvisorValidationPolicySpec {
	if m != nil {
		return m.Policy
	}
	return AdvisorValidationPolicySpec{}
}

func (m *AdvisorValidationProfile) GetProfileDefinition() *AdvisorProfileDef {
	if m != nil {
		return m.ProfileDefinition
	}
	return nil
}

type AdvisorTestConfig struct {
	TestId       string                    `protobuf:"bytes,1,opt,name=TestId,proto3" json:"TestId,omitempty"`
	Action       string                    `protobuf:"bytes,2,opt,name=Action,proto3" json:"Action,omitempty" default:"alert" validate:"required,eq=alert | eq=deny | eq=allow" doc:"Admission action"`
	Severity     string                    `protobuf:"bytes,3,opt,name=Severity,proto3" json:"Severity,omitempty" default:"High" validate:"required,eq=Critical | eq=High | eq=Medium | eq=Low | eq=Pass" doc:"Check Severity"`
	SkipResource []string                  `protobuf:"bytes,4,rep,name=SkipResource" json:"SkipResource,omitempty" doc:"Specify list of resources to skip this check. Each item should follow resource-kind/namespace/name "`
	Items        []*AdvisorCheckConfigItem `protobuf:"bytes,5,rep,name=items" json:"items,omitempty"`
}

func (m *AdvisorTestConfig) Reset()                    { *m = AdvisorTestConfig{} }
func (m *AdvisorTestConfig) String() string            { return proto.CompactTextString(m) }
func (*AdvisorTestConfig) ProtoMessage()               {}
func (*AdvisorTestConfig) Descriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{12} }

func (m *AdvisorTestConfig) GetTestId() string {
	if m != nil {
		return m.TestId
	}
	return ""
}

func (m *AdvisorTestConfig) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *AdvisorTestConfig) GetSeverity() string {
	if m != nil {
		return m.Severity
	}
	return ""
}

func (m *AdvisorTestConfig) GetSkipResource() []string {
	if m != nil {
		return m.SkipResource
	}
	return nil
}

func (m *AdvisorTestConfig) GetItems() []*AdvisorCheckConfigItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type AdvisorProfileDef struct {
	ProfileName      string               `protobuf:"bytes,1,opt,name=profileName,proto3" json:"profileName,omitempty"`
	TemplateId       string               `protobuf:"bytes,2,opt,name=templateId,proto3" json:"templateId,omitempty"`
	TestConfig       []*AdvisorTestConfig `protobuf:"bytes,3,rep,name=testConfig" json:"testConfig,omitempty"`
	Scope            *AdvisorPolicyScope  `protobuf:"bytes,4,opt,name=Scope" json:"Scope,omitempty"`
	ProfileId        string               `protobuf:"bytes,5,opt,name=profileId,proto3" json:"profileId,omitempty"`
	ModifiedBy       string               `protobuf:"bytes,6,opt,name=modifiedBy,proto3" json:"modifiedBy,omitempty"`
	Enabled          bool                 `protobuf:"varint,7,opt,name=enabled,proto3" json:"enabled,omitempty"`
	ModificationDate int64                `protobuf:"varint,8,opt,name=modificationDate,proto3" json:"modificationDate,omitempty"`
}

func (m *AdvisorProfileDef) Reset()                    { *m = AdvisorProfileDef{} }
func (m *AdvisorProfileDef) String() string            { return proto.CompactTextString(m) }
func (*AdvisorProfileDef) ProtoMessage()               {}
func (*AdvisorProfileDef) Descriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{13} }

func (m *AdvisorProfileDef) GetProfileName() string {
	if m != nil {
		return m.ProfileName
	}
	return ""
}

func (m *AdvisorProfileDef) GetTemplateId() string {
	if m != nil {
		return m.TemplateId
	}
	return ""
}

func (m *AdvisorProfileDef) GetTestConfig() []*AdvisorTestConfig {
	if m != nil {
		return m.TestConfig
	}
	return nil
}

func (m *AdvisorProfileDef) GetScope() *AdvisorPolicyScope {
	if m != nil {
		return m.Scope
	}
	return nil
}

func (m *AdvisorProfileDef) GetProfileId() string {
	if m != nil {
		return m.ProfileId
	}
	return ""
}

func (m *AdvisorProfileDef) GetModifiedBy() string {
	if m != nil {
		return m.ModifiedBy
	}
	return ""
}

func (m *AdvisorProfileDef) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *AdvisorProfileDef) GetModificationDate() int64 {
	if m != nil {
		return m.ModificationDate
	}
	return 0
}

// Pod Security Policy Spec defines the policy enforced.
type AdvisorValidationPolicySpec struct {
	Modules []AdvisorCheckModule `protobuf:"bytes,50,rep,name=Modules" json:"Modules"`
}

func (m *AdvisorValidationPolicySpec) Reset()         { *m = AdvisorValidationPolicySpec{} }
func (m *AdvisorValidationPolicySpec) String() string { return proto.CompactTextString(m) }
func (*AdvisorValidationPolicySpec) ProtoMessage()    {}
func (*AdvisorValidationPolicySpec) Descriptor() ([]byte, []int) {
	return fileDescriptorAdvisor, []int{14}
}

func (m *AdvisorValidationPolicySpec) GetModules() []AdvisorCheckModule {
	if m != nil {
		return m.Modules
	}
	return nil
}

type CheckResult struct {
	// Check Id
	CheckId string `protobuf:"bytes,1,opt,name=CheckId,proto3" json:"CheckId,omitempty"`
	// Check Category
	Category string `protobuf:"bytes,2,opt,name=Category,proto3" json:"Category,omitempty"`
	// info, warn, error
	Severity string `protobuf:"bytes,3,opt,name=Severity,proto3" json:"Severity,omitempty"`
	// Admission Action if relevant
	Action string `protobuf:"bytes,4,opt,name=Action,proto3" json:"Action,omitempty"`
	// Advice itself
	Message string `protobuf:"bytes,5,opt,name=Message,proto3" json:"Message,omitempty"`
	// Recommendation
	Recommendation string `protobuf:"bytes,6,opt,name=Recommendation,proto3" json:"Recommendation,omitempty"`
	// Url for more info
	// Deperecated
	Url string `protobuf:"bytes,7,opt,name=Url,proto3" json:"Url,omitempty"`
	// Additional tags related to this check
	Platform string `protobuf:"bytes,8,opt,name=Platform,proto3" json:"Platform,omitempty"`
	// Urls for more info
	References []string `protobuf:"bytes,9,rep,name=References" json:"References,omitempty"`
	// Recommendation
	Tags map[string]string `protobuf:"bytes,10,rep,name=Tags" json:"Tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// A unique stable check UID that can be tracked over repeated scans
	ResultUID string `protobuf:"bytes,11,opt,name=ResultUID,proto3" json:"ResultUID,omitempty"`
	// Denotes whether this resource is new/deleted/modified in respect to the previous report
	DeltaOp string `protobuf:"bytes,12,opt,name=DeltaOp,proto3" json:"DeltaOp,omitempty"`
	// Wider Context if avail.
	Resource ResourceInfo `protobuf:"bytes,13,opt,name=Resource" json:"Resource"`
	Check    CheckInfo    `protobuf:"bytes,14,opt,name=Check" json:"Check"`
	// Additional Findings associated with the resource
	AdditionalFindings map[string]*AdditionalFindings `protobuf:"bytes,15,rep,name=AdditionalFindings" json:"AdditionalFindings,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *CheckResult) Reset()                    { *m = CheckResult{} }
func (m *CheckResult) String() string            { return proto.CompactTextString(m) }
func (*CheckResult) ProtoMessage()               {}
func (*CheckResult) Descriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{15} }

func (m *CheckResult) GetCheckId() string {
	if m != nil {
		return m.CheckId
	}
	return ""
}

func (m *CheckResult) GetCategory() string {
	if m != nil {
		return m.Category
	}
	return ""
}

func (m *CheckResult) GetSeverity() string {
	if m != nil {
		return m.Severity
	}
	return ""
}

func (m *CheckResult) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *CheckResult) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *CheckResult) GetRecommendation() string {
	if m != nil {
		return m.Recommendation
	}
	return ""
}

func (m *CheckResult) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *CheckResult) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *CheckResult) GetReferences() []string {
	if m != nil {
		return m.References
	}
	return nil
}

func (m *CheckResult) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *CheckResult) GetResultUID() string {
	if m != nil {
		return m.ResultUID
	}
	return ""
}

func (m *CheckResult) GetDeltaOp() string {
	if m != nil {
		return m.DeltaOp
	}
	return ""
}

func (m *CheckResult) GetResource() ResourceInfo {
	if m != nil {
		return m.Resource
	}
	return ResourceInfo{}
}

func (m *CheckResult) GetCheck() CheckInfo {
	if m != nil {
		return m.Check
	}
	return CheckInfo{}
}

func (m *CheckResult) GetAdditionalFindings() map[string]*AdditionalFindings {
	if m != nil {
		return m.AdditionalFindings
	}
	return nil
}

type ResourceInfo struct {
	Kind        string            `protobuf:"bytes,20,opt,name=Kind,proto3" json:"Kind,omitempty"`
	Version     string            `protobuf:"bytes,21,opt,name=Version,proto3" json:"Version,omitempty"`
	Group       string            `protobuf:"bytes,22,opt,name=Group,proto3" json:"Group,omitempty"`
	Name        string            `protobuf:"bytes,23,opt,name=Name,proto3" json:"Name,omitempty"`
	Namespace   string            `protobuf:"bytes,24,opt,name=Namespace,proto3" json:"Namespace,omitempty"`
	Annotations map[string]string `protobuf:"bytes,25,rep,name=Annotations" json:"Annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Labels      map[string]string `protobuf:"bytes,26,rep,name=Labels" json:"Labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ResourceInfo) Reset()                    { *m = ResourceInfo{} }
func (m *ResourceInfo) String() string            { return proto.CompactTextString(m) }
func (*ResourceInfo) ProtoMessage()               {}
func (*ResourceInfo) Descriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{16} }

func (m *ResourceInfo) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *ResourceInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *ResourceInfo) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *ResourceInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ResourceInfo) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ResourceInfo) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ResourceInfo) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

type CheckInfo struct {
	ModuleTitle string `protobuf:"bytes,20,opt,name=ModuleTitle,proto3" json:"ModuleTitle,omitempty"`
	GroupTitle  string `protobuf:"bytes,21,opt,name=GroupTitle,proto3" json:"GroupTitle,omitempty"`
	CheckTitle  string `protobuf:"bytes,22,opt,name=CheckTitle,proto3" json:"CheckTitle,omitempty"`
	ModuleId    string `protobuf:"bytes,23,opt,name=ModuleId,proto3" json:"ModuleId,omitempty"`
	GroupId     string `protobuf:"bytes,24,opt,name=GroupId,proto3" json:"GroupId,omitempty"`
	CheckId     string `protobuf:"bytes,25,opt,name=CheckId,proto3" json:"CheckId,omitempty"`
}

func (m *CheckInfo) Reset()                    { *m = CheckInfo{} }
func (m *CheckInfo) String() string            { return proto.CompactTextString(m) }
func (*CheckInfo) ProtoMessage()               {}
func (*CheckInfo) Descriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{17} }

func (m *CheckInfo) GetModuleTitle() string {
	if m != nil {
		return m.ModuleTitle
	}
	return ""
}

func (m *CheckInfo) GetGroupTitle() string {
	if m != nil {
		return m.GroupTitle
	}
	return ""
}

func (m *CheckInfo) GetCheckTitle() string {
	if m != nil {
		return m.CheckTitle
	}
	return ""
}

func (m *CheckInfo) GetModuleId() string {
	if m != nil {
		return m.ModuleId
	}
	return ""
}

func (m *CheckInfo) GetGroupId() string {
	if m != nil {
		return m.GroupId
	}
	return ""
}

func (m *CheckInfo) GetCheckId() string {
	if m != nil {
		return m.CheckId
	}
	return ""
}

type AdditionalFinding struct {
	Id          string            `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" default:"" doc:"CVE-xxx-yyy,..."`
	Title       string            `protobuf:"bytes,2,opt,name=Title,proto3" json:"Title,omitempty" default:"" doc:"Title"`
	Description string            `protobuf:"bytes,3,opt,name=Description,proto3" json:"Description,omitempty" default:"" doc:"Description"`
	Severity    string            `protobuf:"bytes,4,opt,name=Severity,proto3" json:"Severity,omitempty" default:"" doc:"Severity "`
	References  []string          `protobuf:"bytes,5,rep,name=References" json:"References,omitempty" default:"" doc:"URL Reference Array"`
	Info        map[string]string `protobuf:"bytes,6,rep,name=Info" json:"Info,omitempty" default:"" doc:"Additional Info" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *AdditionalFinding) Reset()                    { *m = AdditionalFinding{} }
func (m *AdditionalFinding) String() string            { return proto.CompactTextString(m) }
func (*AdditionalFinding) ProtoMessage()               {}
func (*AdditionalFinding) Descriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{18} }

func (m *AdditionalFinding) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AdditionalFinding) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *AdditionalFinding) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *AdditionalFinding) GetSeverity() string {
	if m != nil {
		return m.Severity
	}
	return ""
}

func (m *AdditionalFinding) GetReferences() []string {
	if m != nil {
		return m.References
	}
	return nil
}

func (m *AdditionalFinding) GetInfo() map[string]string {
	if m != nil {
		return m.Info
	}
	return nil
}

type AdditionalFindings struct {
	// Summary
	SeverityCount map[string]int32     `protobuf:"bytes,1,rep,name=SeverityCount" json:"SeverityCount,omitempty" default:"" doc:"Severity total count" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Severity      string               `protobuf:"bytes,2,opt,name=Severity,proto3" json:"Severity,omitempty" default:"Info" doc:"Aggregated Severity"`
	Findings      []*AdditionalFinding `protobuf:"bytes,3,rep,name=Findings" json:"Findings,omitempty"`
}

func (m *AdditionalFindings) Reset()                    { *m = AdditionalFindings{} }
func (m *AdditionalFindings) String() string            { return proto.CompactTextString(m) }
func (*AdditionalFindings) ProtoMessage()               {}
func (*AdditionalFindings) Descriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{19} }

func (m *AdditionalFindings) GetSeverityCount() map[string]int32 {
	if m != nil {
		return m.SeverityCount
	}
	return nil
}

func (m *AdditionalFindings) GetSeverity() string {
	if m != nil {
		return m.Severity
	}
	return ""
}

func (m *AdditionalFindings) GetFindings() []*AdditionalFinding {
	if m != nil {
		return m.Findings
	}
	return nil
}

type AdvisorReportHeader struct {
	// CreationTimestamp is a timestamp representing the time when this Node was
	// created. It is represented in RFC3339 form and is in UTC.
	CreationTimeStamp string `protobuf:"bytes,1,opt,name=CreationTimeStamp,proto3" json:"CreationTimeStamp,omitempty"`
	// report uuid.. uniquely identifies the report instance
	ReportUID string `protobuf:"bytes,2,opt,name=ReportUID,proto3" json:"ReportUID,omitempty"`
	// The following fields are used as "physical coordinates" for the source of the alert
	OrganizationUID   string `protobuf:"bytes,3,opt,name=OrganizationUID,proto3" json:"OrganizationUID,omitempty"`
	DataCenterUID     string `protobuf:"bytes,4,opt,name=DataCenterUID,proto3" json:"DataCenterUID,omitempty"`
	ClusterUID        string `protobuf:"bytes,5,opt,name=ClusterUID,proto3" json:"ClusterUID,omitempty"`
	KubernetesVersion string `protobuf:"bytes,6,opt,name=KubernetesVersion,proto3" json:"KubernetesVersion,omitempty"`
	Info              string `protobuf:"bytes,7,opt,name=Info,proto3" json:"Info,omitempty"`
	ScannerVersion    string `protobuf:"bytes,8,opt,name=ScannerVersion,proto3" json:"ScannerVersion,omitempty"`
	MSTimeStamp       int64  `protobuf:"varint,9,opt,name=MSTimeStamp,proto3" json:"MSTimeStamp,omitempty"`
	ProfileID         string `protobuf:"bytes,10,opt,name=ProfileID,proto3" json:"ProfileID,omitempty"`
}

func (m *AdvisorReportHeader) Reset()                    { *m = AdvisorReportHeader{} }
func (m *AdvisorReportHeader) String() string            { return proto.CompactTextString(m) }
func (*AdvisorReportHeader) ProtoMessage()               {}
func (*AdvisorReportHeader) Descriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{20} }

func (m *AdvisorReportHeader) GetCreationTimeStamp() string {
	if m != nil {
		return m.CreationTimeStamp
	}
	return ""
}

func (m *AdvisorReportHeader) GetReportUID() string {
	if m != nil {
		return m.ReportUID
	}
	return ""
}

func (m *AdvisorReportHeader) GetOrganizationUID() string {
	if m != nil {
		return m.OrganizationUID
	}
	return ""
}

func (m *AdvisorReportHeader) GetDataCenterUID() string {
	if m != nil {
		return m.DataCenterUID
	}
	return ""
}

func (m *AdvisorReportHeader) GetClusterUID() string {
	if m != nil {
		return m.ClusterUID
	}
	return ""
}

func (m *AdvisorReportHeader) GetKubernetesVersion() string {
	if m != nil {
		return m.KubernetesVersion
	}
	return ""
}

func (m *AdvisorReportHeader) GetInfo() string {
	if m != nil {
		return m.Info
	}
	return ""
}

func (m *AdvisorReportHeader) GetScannerVersion() string {
	if m != nil {
		return m.ScannerVersion
	}
	return ""
}

func (m *AdvisorReportHeader) GetMSTimeStamp() int64 {
	if m != nil {
		return m.MSTimeStamp
	}
	return 0
}

func (m *AdvisorReportHeader) GetProfileID() string {
	if m != nil {
		return m.ProfileID
	}
	return ""
}

type AdvisorReportData struct {
	// Module Info
	ResourceName string `protobuf:"bytes,1,opt,name=ResourceName,proto3" json:"ResourceName,omitempty"`
	// If applicable
	ResourceNamespace string `protobuf:"bytes,2,opt,name=ResourceNamespace,proto3" json:"ResourceNamespace,omitempty"`
	// If applicable
	ResourceUID string `protobuf:"bytes,3,opt,name=ResourceUID,proto3" json:"ResourceUID,omitempty"`
	// Orchestration Kind
	ResourceKind string `protobuf:"bytes,4,opt,name=ResourceKind,proto3" json:"ResourceKind,omitempty"`
	// Deprecated
	ServiceAccount string `protobuf:"bytes,5,opt,name=ServiceAccount,proto3" json:"ServiceAccount,omitempty"`
	// Deprecated
	// Resource fingerprint - captures approximation of microservice ID
	Fingerprint string `protobuf:"bytes,6,opt,name=Fingerprint,proto3" json:"Fingerprint,omitempty"`
	// Deprecated
	// SnapshotId - captures a microservicee revision (new build in simpler words)
	SnapshotId string `protobuf:"bytes,7,opt,name=SnapshotId,proto3" json:"SnapshotId,omitempty"`
	// Deprecated
	// Denotes whether this resource is new/deleted/modified in respect to the previous report
	DeltaOp string `protobuf:"bytes,8,opt,name=DeltaOp,proto3" json:"DeltaOp,omitempty"`
	// Deprecated
	// Orchestration Kind
	Images     []string `protobuf:"bytes,16,rep,name=Images" json:"Images,omitempty"`
	InitImages []string `protobuf:"bytes,17,rep,name=InitImages" json:"InitImages,omitempty"`
	// Deprecated
	Labels map[string]string `protobuf:"bytes,18,rep,name=Labels" json:"Labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Deprecated
	Annotations map[string]string `protobuf:"bytes,19,rep,name=Annotations" json:"Annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Results     []CheckResult     `protobuf:"bytes,20,rep,name=Results" json:"Results"`
}

func (m *AdvisorReportData) Reset()                    { *m = AdvisorReportData{} }
func (m *AdvisorReportData) String() string            { return proto.CompactTextString(m) }
func (*AdvisorReportData) ProtoMessage()               {}
func (*AdvisorReportData) Descriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{21} }

func (m *AdvisorReportData) GetResourceName() string {
	if m != nil {
		return m.ResourceName
	}
	return ""
}

func (m *AdvisorReportData) GetResourceNamespace() string {
	if m != nil {
		return m.ResourceNamespace
	}
	return ""
}

func (m *AdvisorReportData) GetResourceUID() string {
	if m != nil {
		return m.ResourceUID
	}
	return ""
}

func (m *AdvisorReportData) GetResourceKind() string {
	if m != nil {
		return m.ResourceKind
	}
	return ""
}

func (m *AdvisorReportData) GetServiceAccount() string {
	if m != nil {
		return m.ServiceAccount
	}
	return ""
}

func (m *AdvisorReportData) GetFingerprint() string {
	if m != nil {
		return m.Fingerprint
	}
	return ""
}

func (m *AdvisorReportData) GetSnapshotId() string {
	if m != nil {
		return m.SnapshotId
	}
	return ""
}

func (m *AdvisorReportData) GetDeltaOp() string {
	if m != nil {
		return m.DeltaOp
	}
	return ""
}

func (m *AdvisorReportData) GetImages() []string {
	if m != nil {
		return m.Images
	}
	return nil
}

func (m *AdvisorReportData) GetInitImages() []string {
	if m != nil {
		return m.InitImages
	}
	return nil
}

func (m *AdvisorReportData) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *AdvisorReportData) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *AdvisorReportData) GetResults() []CheckResult {
	if m != nil {
		return m.Results
	}
	return nil
}

type AdvisorReport struct {
	AdvisorReportHeader `protobuf:"bytes,1,opt,name=Header,embedded=Header" json:"Header" `
	AdvisorReportData   `protobuf:"bytes,2,opt,name=Data,embedded=Data" json:"Data" `
}

func (m *AdvisorReport) Reset()                    { *m = AdvisorReport{} }
func (m *AdvisorReport) String() string            { return proto.CompactTextString(m) }
func (*AdvisorReport) ProtoMessage()               {}
func (*AdvisorReport) Descriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{22} }

type AdvisorClusterReport struct {
	AdvisorReportHeader `protobuf:"bytes,1,opt,name=AdvisorReportHeader,embedded=AdvisorReportHeader" json:"AdvisorReportHeader" `
	Reports             map[string]*AdvisorReportData `protobuf:"bytes,2,rep,name=Reports" json:"Reports,omitempty"  protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *AdvisorClusterReport) Reset()                    { *m = AdvisorClusterReport{} }
func (m *AdvisorClusterReport) String() string            { return proto.CompactTextString(m) }
func (*AdvisorClusterReport) ProtoMessage()               {}
func (*AdvisorClusterReport) Descriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{23} }

func (m *AdvisorClusterReport) GetReports() map[string]*AdvisorReportData {
	if m != nil {
		return m.Reports
	}
	return nil
}

type AdvisorClusterDiffReport struct {
	PreviousReportHeader AdvisorReportHeader           `protobuf:"bytes,1,opt,name=PreviousReportHeader" json:"PreviousReportHeader" `
	CurrentReportHeader  AdvisorReportHeader           `protobuf:"bytes,2,opt,name=CurrentReportHeader" json:"CurrentReportHeader" `
	Reports              map[string]*AdvisorReportData `protobuf:"bytes,3,rep,name=Reports" json:"Reports,omitempty"  protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *AdvisorClusterDiffReport) Reset()                    { *m = AdvisorClusterDiffReport{} }
func (m *AdvisorClusterDiffReport) String() string            { return proto.CompactTextString(m) }
func (*AdvisorClusterDiffReport) ProtoMessage()               {}
func (*AdvisorClusterDiffReport) Descriptor() ([]byte, []int) { return fileDescriptorAdvisor, []int{24} }

func (m *AdvisorClusterDiffReport) GetPreviousReportHeader() AdvisorReportHeader {
	if m != nil {
		return m.PreviousReportHeader
	}
	return AdvisorReportHeader{}
}

func (m *AdvisorClusterDiffReport) GetCurrentReportHeader() AdvisorReportHeader {
	if m != nil {
		return m.CurrentReportHeader
	}
	return AdvisorReportHeader{}
}

func (m *AdvisorClusterDiffReport) GetReports() map[string]*AdvisorReportData {
	if m != nil {
		return m.Reports
	}
	return nil
}

func init() {
	proto.RegisterType((*AdvisorCheckFeatureBool)(nil), "advisor.AdvisorCheckFeatureBool")
	proto.RegisterType((*AdvisorCheckFeatureStringSet)(nil), "advisor.AdvisorCheckFeatureStringSet")
	proto.RegisterType((*AdvisorHostPathRule)(nil), "advisor.AdvisorHostPathRule")
	proto.RegisterType((*AdvisorCheckFeatureAlcideRules)(nil), "advisor.AdvisorCheckFeatureAlcideRules")
	proto.RegisterType((*AdvisorCheckConfigItem)(nil), "advisor.AdvisorCheckConfigItem")
	proto.RegisterType((*AdvisorConfigDescriptor)(nil), "advisor.AdvisorConfigDescriptor")
	proto.RegisterType((*AdvisorModuleItem)(nil), "advisor.AdvisorModuleItem")
	proto.RegisterType((*AdvisorResourceCheck)(nil), "advisor.AdvisorResourceCheck")
	proto.RegisterType((*AdvisorResourceCheckGroup)(nil), "advisor.AdvisorResourceCheckGroup")
	proto.RegisterType((*AdvisorCheckModule)(nil), "advisor.AdvisorCheckModule")
	proto.RegisterType((*AdvisorPolicyScope)(nil), "advisor.AdvisorPolicyScope")
	proto.RegisterType((*AdvisorValidationProfile)(nil), "advisor.AdvisorValidationProfile")
	proto.RegisterType((*AdvisorTestConfig)(nil), "advisor.AdvisorTestConfig")
	proto.RegisterType((*AdvisorProfileDef)(nil), "advisor.AdvisorProfileDef")
	proto.RegisterType((*AdvisorValidationPolicySpec)(nil), "advisor.AdvisorValidationPolicySpec")
	proto.RegisterType((*CheckResult)(nil), "advisor.CheckResult")
	proto.RegisterType((*ResourceInfo)(nil), "advisor.ResourceInfo")
	proto.RegisterType((*CheckInfo)(nil), "advisor.CheckInfo")
	proto.RegisterType((*AdditionalFinding)(nil), "advisor.AdditionalFinding")
	proto.RegisterType((*AdditionalFindings)(nil), "advisor.AdditionalFindings")
	proto.RegisterType((*AdvisorReportHeader)(nil), "advisor.AdvisorReportHeader")
	proto.RegisterType((*AdvisorReportData)(nil), "advisor.AdvisorReportData")
	proto.RegisterType((*AdvisorReport)(nil), "advisor.AdvisorReport")
	proto.RegisterType((*AdvisorClusterReport)(nil), "advisor.AdvisorClusterReport")
	proto.RegisterType((*AdvisorClusterDiffReport)(nil), "advisor.AdvisorClusterDiffReport")
	proto.RegisterEnum("advisor.Platform", Platform_name, Platform_value)
	proto.RegisterEnum("advisor.CheckId", CheckId_name, CheckId_value)
	proto.RegisterEnum("advisor.CheckSeverity", CheckSeverity_name, CheckSeverity_value)
	proto.RegisterEnum("advisor.AdmissionAction", AdmissionAction_name, AdmissionAction_value)
	proto.RegisterEnum("advisor.CheckCategory", CheckCategory_name, CheckCategory_value)
	proto.RegisterEnum("advisor.CheckApplicabilityType", CheckApplicabilityType_name, CheckApplicabilityType_value)
	proto.RegisterEnum("advisor.ConfigItemType", ConfigItemType_name, ConfigItemType_value)
	proto.RegisterEnum("advisor.PricePlanType", PricePlanType_name, PricePlanType_value)
	proto.RegisterEnum("advisor.DeltaOp", DeltaOp_name, DeltaOp_value)
}
func (m *AdvisorCheckFeatureBool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvisorCheckFeatureBool) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Action) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Action)))
		i += copy(dAtA[i:], m.Action)
	}
	if len(m.AlertTags) > 0 {
		for k, _ := range m.AlertTags {
			dAtA[i] = 0x12
			i++
			v := m.AlertTags[k]
			mapSize := 1 + len(k) + sovAdvisor(uint64(len(k))) + 1 + len(v) + sovAdvisor(uint64(len(v)))
			i = encodeVarintAdvisor(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.OverrideAnnotation) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.OverrideAnnotation)))
		i += copy(dAtA[i:], m.OverrideAnnotation)
	}
	if m.Expected {
		dAtA[i] = 0x20
		i++
		if m.Expected {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.SkipResource) > 0 {
		for _, s := range m.SkipResource {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Severity) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Severity)))
		i += copy(dAtA[i:], m.Severity)
	}
	return i, nil
}

func (m *AdvisorCheckFeatureStringSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvisorCheckFeatureStringSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Action) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Action)))
		i += copy(dAtA[i:], m.Action)
	}
	if len(m.AlertTags) > 0 {
		for k, _ := range m.AlertTags {
			dAtA[i] = 0x12
			i++
			v := m.AlertTags[k]
			mapSize := 1 + len(k) + sovAdvisor(uint64(len(k))) + 1 + len(v) + sovAdvisor(uint64(len(v)))
			i = encodeVarintAdvisor(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.OverrideAnnotation) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.OverrideAnnotation)))
		i += copy(dAtA[i:], m.OverrideAnnotation)
	}
	if len(m.Expected) > 0 {
		for _, s := range m.Expected {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.SkipResource) > 0 {
		for _, s := range m.SkipResource {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Severity) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Severity)))
		i += copy(dAtA[i:], m.Severity)
	}
	return i, nil
}

func (m *AdvisorHostPathRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvisorHostPathRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if m.ReadOnly {
		dAtA[i] = 0x10
		i++
		if m.ReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AdvisorCheckFeatureAlcideRules) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvisorCheckFeatureAlcideRules) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Action) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Action)))
		i += copy(dAtA[i:], m.Action)
	}
	if len(m.AlertTags) > 0 {
		for k, _ := range m.AlertTags {
			dAtA[i] = 0x12
			i++
			v := m.AlertTags[k]
			mapSize := 1 + len(k) + sovAdvisor(uint64(len(k))) + 1 + len(v) + sovAdvisor(uint64(len(v)))
			i = encodeVarintAdvisor(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.OverrideAnnotation) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.OverrideAnnotation)))
		i += copy(dAtA[i:], m.OverrideAnnotation)
	}
	if len(m.ExpectedInbound) > 0 {
		for _, s := range m.ExpectedInbound {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ExpectedOutbound) > 0 {
		for _, s := range m.ExpectedOutbound {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.SkipResource) > 0 {
		for _, s := range m.SkipResource {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Severity) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Severity)))
		i += copy(dAtA[i:], m.Severity)
	}
	return i, nil
}

func (m *AdvisorCheckConfigItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvisorCheckConfigItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Item) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Item)))
		i += copy(dAtA[i:], m.Item)
	}
	return i, nil
}

func (m *AdvisorConfigDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvisorConfigDescriptor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Title) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if len(m.Placeholder) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Placeholder)))
		i += copy(dAtA[i:], m.Placeholder)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	return i, nil
}

func (m *AdvisorModuleItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvisorModuleItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Item) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Item)))
		i += copy(dAtA[i:], m.Item)
	}
	return i, nil
}

func (m *AdvisorResourceCheck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvisorResourceCheck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Action) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Action)))
		i += copy(dAtA[i:], m.Action)
	}
	if len(m.Severity) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Severity)))
		i += copy(dAtA[i:], m.Severity)
	}
	if len(m.Requirements) > 0 {
		for _, s := range m.Requirements {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Expected) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Expected)))
		i += copy(dAtA[i:], m.Expected)
	}
	if len(m.PreRequisites) > 0 {
		for _, s := range m.PreRequisites {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if len(m.Recommendation) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Recommendation)))
		i += copy(dAtA[i:], m.Recommendation)
	}
	if len(m.References) > 0 {
		for _, s := range m.References {
			dAtA[i] = 0x5a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.OverrideAnnotation) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.OverrideAnnotation)))
		i += copy(dAtA[i:], m.OverrideAnnotation)
	}
	if len(m.SkipResource) > 0 {
		for _, s := range m.SkipResource {
			dAtA[i] = 0x6a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Config) > 0 {
		for _, msg := range m.Config {
			dAtA[i] = 0x72
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MandatoryConfigItems {
		dAtA[i] = 0x78
		i++
		if m.MandatoryConfigItems {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ConfigDescriptor != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(m.ConfigDescriptor.Size()))
		n1, err := m.ConfigDescriptor.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.CheckApplicability) > 0 {
		dAtA3 := make([]byte, len(m.CheckApplicability)*10)
		var j2 int
		for _, num := range m.CheckApplicability {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	return i, nil
}

func (m *AdvisorResourceCheckGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvisorResourceCheckGroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GroupID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.GroupID)))
		i += copy(dAtA[i:], m.GroupID)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.ResourceSelector) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.ResourceSelector)))
		i += copy(dAtA[i:], m.ResourceSelector)
	}
	if len(m.SkipResource) > 0 {
		for _, s := range m.SkipResource {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Checks) > 0 {
		for _, msg := range m.Checks {
			dAtA[i] = 0x32
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AdvisorCheckModule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvisorCheckModule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Platform) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	if len(m.Groups) > 0 {
		for _, msg := range m.Groups {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PreRequisites) > 0 {
		for _, s := range m.PreRequisites {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.ReportPassedChecks {
		dAtA[i] = 0x38
		i++
		if m.ReportPassedChecks {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x42
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ConfigItems) > 0 {
		for _, msg := range m.ConfigItems {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AdvisorPolicyScope) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvisorPolicyScope) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NamespaceInclude) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.NamespaceInclude)))
		i += copy(dAtA[i:], m.NamespaceInclude)
	}
	if len(m.NamespaceExclude) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.NamespaceExclude)))
		i += copy(dAtA[i:], m.NamespaceExclude)
	}
	if len(m.Clusters) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Clusters)))
		i += copy(dAtA[i:], m.Clusters)
	}
	if len(m.ClustersExclude) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.ClustersExclude)))
		i += copy(dAtA[i:], m.ClustersExclude)
	}
	return i, nil
}

func (m *AdvisorValidationProfile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvisorValidationProfile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.UID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.UID)))
		i += copy(dAtA[i:], m.UID)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if m.PricePlan != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(m.PricePlan))
	}
	if len(m.ProfileID) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.ProfileID)))
		i += copy(dAtA[i:], m.ProfileID)
	}
	dAtA[i] = 0x52
	i++
	i = encodeVarintAdvisor(dAtA, i, uint64(m.Scope.Size()))
	n4, err := m.Scope.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if m.ApplyOnAdmission {
		dAtA[i] = 0x58
		i++
		if m.ApplyOnAdmission {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ApplyOnScan {
		dAtA[i] = 0x60
		i++
		if m.ApplyOnScan {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	dAtA[i] = 0x6a
	i++
	i = encodeVarintAdvisor(dAtA, i, uint64(m.Policy.Size()))
	n5, err := m.Policy.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	if m.ProfileDefinition != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(m.ProfileDefinition.Size()))
		n6, err := m.ProfileDefinition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *AdvisorTestConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvisorTestConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TestId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.TestId)))
		i += copy(dAtA[i:], m.TestId)
	}
	if len(m.Action) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Action)))
		i += copy(dAtA[i:], m.Action)
	}
	if len(m.Severity) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Severity)))
		i += copy(dAtA[i:], m.Severity)
	}
	if len(m.SkipResource) > 0 {
		for _, s := range m.SkipResource {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AdvisorProfileDef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvisorProfileDef) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProfileName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.ProfileName)))
		i += copy(dAtA[i:], m.ProfileName)
	}
	if len(m.TemplateId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.TemplateId)))
		i += copy(dAtA[i:], m.TemplateId)
	}
	if len(m.TestConfig) > 0 {
		for _, msg := range m.TestConfig {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Scope != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(m.Scope.Size()))
		n7, err := m.Scope.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.ProfileId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.ProfileId)))
		i += copy(dAtA[i:], m.ProfileId)
	}
	if len(m.ModifiedBy) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.ModifiedBy)))
		i += copy(dAtA[i:], m.ModifiedBy)
	}
	if m.Enabled {
		dAtA[i] = 0x38
		i++
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ModificationDate != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(m.ModificationDate))
	}
	return i, nil
}

func (m *AdvisorValidationPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvisorValidationPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Modules) > 0 {
		for _, msg := range m.Modules {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x3
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CheckResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CheckId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.CheckId)))
		i += copy(dAtA[i:], m.CheckId)
	}
	if len(m.Category) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Category)))
		i += copy(dAtA[i:], m.Category)
	}
	if len(m.Severity) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Severity)))
		i += copy(dAtA[i:], m.Severity)
	}
	if len(m.Action) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Action)))
		i += copy(dAtA[i:], m.Action)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if len(m.Recommendation) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Recommendation)))
		i += copy(dAtA[i:], m.Recommendation)
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if len(m.Platform) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	if len(m.References) > 0 {
		for _, s := range m.References {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Tags) > 0 {
		for k, _ := range m.Tags {
			dAtA[i] = 0x52
			i++
			v := m.Tags[k]
			mapSize := 1 + len(k) + sovAdvisor(uint64(len(k))) + 1 + len(v) + sovAdvisor(uint64(len(v)))
			i = encodeVarintAdvisor(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.ResultUID) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.ResultUID)))
		i += copy(dAtA[i:], m.ResultUID)
	}
	if len(m.DeltaOp) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.DeltaOp)))
		i += copy(dAtA[i:], m.DeltaOp)
	}
	dAtA[i] = 0x6a
	i++
	i = encodeVarintAdvisor(dAtA, i, uint64(m.Resource.Size()))
	n8, err := m.Resource.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	dAtA[i] = 0x72
	i++
	i = encodeVarintAdvisor(dAtA, i, uint64(m.Check.Size()))
	n9, err := m.Check.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	if len(m.AdditionalFindings) > 0 {
		for k, _ := range m.AdditionalFindings {
			dAtA[i] = 0x7a
			i++
			v := m.AdditionalFindings[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovAdvisor(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovAdvisor(uint64(len(k))) + msgSize
			i = encodeVarintAdvisor(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintAdvisor(dAtA, i, uint64(v.Size()))
				n10, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n10
			}
		}
	}
	return i, nil
}

func (m *ResourceInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kind) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Kind)))
		i += copy(dAtA[i:], m.Kind)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.Group) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Group)))
		i += copy(dAtA[i:], m.Group)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.Annotations) > 0 {
		for k, _ := range m.Annotations {
			dAtA[i] = 0xca
			i++
			dAtA[i] = 0x1
			i++
			v := m.Annotations[k]
			mapSize := 1 + len(k) + sovAdvisor(uint64(len(k))) + 1 + len(v) + sovAdvisor(uint64(len(v)))
			i = encodeVarintAdvisor(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0xd2
			i++
			dAtA[i] = 0x1
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovAdvisor(uint64(len(k))) + 1 + len(v) + sovAdvisor(uint64(len(v)))
			i = encodeVarintAdvisor(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *CheckInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ModuleTitle) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.ModuleTitle)))
		i += copy(dAtA[i:], m.ModuleTitle)
	}
	if len(m.GroupTitle) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.GroupTitle)))
		i += copy(dAtA[i:], m.GroupTitle)
	}
	if len(m.CheckTitle) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.CheckTitle)))
		i += copy(dAtA[i:], m.CheckTitle)
	}
	if len(m.ModuleId) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.ModuleId)))
		i += copy(dAtA[i:], m.ModuleId)
	}
	if len(m.GroupId) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.GroupId)))
		i += copy(dAtA[i:], m.GroupId)
	}
	if len(m.CheckId) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.CheckId)))
		i += copy(dAtA[i:], m.CheckId)
	}
	return i, nil
}

func (m *AdditionalFinding) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdditionalFinding) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Severity) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Severity)))
		i += copy(dAtA[i:], m.Severity)
	}
	if len(m.References) > 0 {
		for _, s := range m.References {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Info) > 0 {
		for k, _ := range m.Info {
			dAtA[i] = 0x32
			i++
			v := m.Info[k]
			mapSize := 1 + len(k) + sovAdvisor(uint64(len(k))) + 1 + len(v) + sovAdvisor(uint64(len(v)))
			i = encodeVarintAdvisor(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *AdditionalFindings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdditionalFindings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SeverityCount) > 0 {
		for k, _ := range m.SeverityCount {
			dAtA[i] = 0xa
			i++
			v := m.SeverityCount[k]
			mapSize := 1 + len(k) + sovAdvisor(uint64(len(k))) + 1 + sovAdvisor(uint64(v))
			i = encodeVarintAdvisor(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(v))
		}
	}
	if len(m.Severity) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Severity)))
		i += copy(dAtA[i:], m.Severity)
	}
	if len(m.Findings) > 0 {
		for _, msg := range m.Findings {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AdvisorReportHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvisorReportHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CreationTimeStamp) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.CreationTimeStamp)))
		i += copy(dAtA[i:], m.CreationTimeStamp)
	}
	if len(m.ReportUID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.ReportUID)))
		i += copy(dAtA[i:], m.ReportUID)
	}
	if len(m.OrganizationUID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.OrganizationUID)))
		i += copy(dAtA[i:], m.OrganizationUID)
	}
	if len(m.DataCenterUID) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.DataCenterUID)))
		i += copy(dAtA[i:], m.DataCenterUID)
	}
	if len(m.ClusterUID) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.ClusterUID)))
		i += copy(dAtA[i:], m.ClusterUID)
	}
	if len(m.KubernetesVersion) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.KubernetesVersion)))
		i += copy(dAtA[i:], m.KubernetesVersion)
	}
	if len(m.Info) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Info)))
		i += copy(dAtA[i:], m.Info)
	}
	if len(m.ScannerVersion) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.ScannerVersion)))
		i += copy(dAtA[i:], m.ScannerVersion)
	}
	if m.MSTimeStamp != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(m.MSTimeStamp))
	}
	if len(m.ProfileID) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.ProfileID)))
		i += copy(dAtA[i:], m.ProfileID)
	}
	return i, nil
}

func (m *AdvisorReportData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvisorReportData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResourceName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.ResourceName)))
		i += copy(dAtA[i:], m.ResourceName)
	}
	if len(m.ResourceNamespace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.ResourceNamespace)))
		i += copy(dAtA[i:], m.ResourceNamespace)
	}
	if len(m.ResourceUID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.ResourceUID)))
		i += copy(dAtA[i:], m.ResourceUID)
	}
	if len(m.ResourceKind) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.ResourceKind)))
		i += copy(dAtA[i:], m.ResourceKind)
	}
	if len(m.ServiceAccount) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.ServiceAccount)))
		i += copy(dAtA[i:], m.ServiceAccount)
	}
	if len(m.Fingerprint) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.Fingerprint)))
		i += copy(dAtA[i:], m.Fingerprint)
	}
	if len(m.SnapshotId) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.SnapshotId)))
		i += copy(dAtA[i:], m.SnapshotId)
	}
	if len(m.DeltaOp) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAdvisor(dAtA, i, uint64(len(m.DeltaOp)))
		i += copy(dAtA[i:], m.DeltaOp)
	}
	if len(m.Images) > 0 {
		for _, s := range m.Images {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.InitImages) > 0 {
		for _, s := range m.InitImages {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovAdvisor(uint64(len(k))) + 1 + len(v) + sovAdvisor(uint64(len(v)))
			i = encodeVarintAdvisor(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Annotations) > 0 {
		for k, _ := range m.Annotations {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x1
			i++
			v := m.Annotations[k]
			mapSize := 1 + len(k) + sovAdvisor(uint64(len(k))) + 1 + len(v) + sovAdvisor(uint64(len(v)))
			i = encodeVarintAdvisor(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Results) > 0 {
		for _, msg := range m.Results {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AdvisorReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvisorReport) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAdvisor(dAtA, i, uint64(m.AdvisorReportHeader.Size()))
	n11, err := m.AdvisorReportHeader.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	dAtA[i] = 0x12
	i++
	i = encodeVarintAdvisor(dAtA, i, uint64(m.AdvisorReportData.Size()))
	n12, err := m.AdvisorReportData.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	return i, nil
}

func (m *AdvisorClusterReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvisorClusterReport) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAdvisor(dAtA, i, uint64(m.AdvisorReportHeader.Size()))
	n13, err := m.AdvisorReportHeader.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	if len(m.Reports) > 0 {
		for k, _ := range m.Reports {
			dAtA[i] = 0x12
			i++
			v := m.Reports[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovAdvisor(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovAdvisor(uint64(len(k))) + msgSize
			i = encodeVarintAdvisor(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintAdvisor(dAtA, i, uint64(v.Size()))
				n14, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n14
			}
		}
	}
	return i, nil
}

func (m *AdvisorClusterDiffReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdvisorClusterDiffReport) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAdvisor(dAtA, i, uint64(m.PreviousReportHeader.Size()))
	n15, err := m.PreviousReportHeader.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	dAtA[i] = 0x12
	i++
	i = encodeVarintAdvisor(dAtA, i, uint64(m.CurrentReportHeader.Size()))
	n16, err := m.CurrentReportHeader.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	if len(m.Reports) > 0 {
		for k, _ := range m.Reports {
			dAtA[i] = 0x1a
			i++
			v := m.Reports[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovAdvisor(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovAdvisor(uint64(len(k))) + msgSize
			i = encodeVarintAdvisor(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintAdvisor(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintAdvisor(dAtA, i, uint64(v.Size()))
				n17, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n17
			}
		}
	}
	return i, nil
}

func encodeVarintAdvisor(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AdvisorCheckFeatureBool) Size() (n int) {
	var l int
	_ = l
	l = len(m.Action)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	if len(m.AlertTags) > 0 {
		for k, v := range m.AlertTags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdvisor(uint64(len(k))) + 1 + len(v) + sovAdvisor(uint64(len(v)))
			n += mapEntrySize + 1 + sovAdvisor(uint64(mapEntrySize))
		}
	}
	l = len(m.OverrideAnnotation)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	if m.Expected {
		n += 2
	}
	if len(m.SkipResource) > 0 {
		for _, s := range m.SkipResource {
			l = len(s)
			n += 1 + l + sovAdvisor(uint64(l))
		}
	}
	l = len(m.Severity)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	return n
}

func (m *AdvisorCheckFeatureStringSet) Size() (n int) {
	var l int
	_ = l
	l = len(m.Action)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	if len(m.AlertTags) > 0 {
		for k, v := range m.AlertTags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdvisor(uint64(len(k))) + 1 + len(v) + sovAdvisor(uint64(len(v)))
			n += mapEntrySize + 1 + sovAdvisor(uint64(mapEntrySize))
		}
	}
	l = len(m.OverrideAnnotation)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	if len(m.Expected) > 0 {
		for _, s := range m.Expected {
			l = len(s)
			n += 1 + l + sovAdvisor(uint64(l))
		}
	}
	if len(m.SkipResource) > 0 {
		for _, s := range m.SkipResource {
			l = len(s)
			n += 1 + l + sovAdvisor(uint64(l))
		}
	}
	l = len(m.Severity)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	return n
}

func (m *AdvisorHostPathRule) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	if m.ReadOnly {
		n += 2
	}
	return n
}

func (m *AdvisorCheckFeatureAlcideRules) Size() (n int) {
	var l int
	_ = l
	l = len(m.Action)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	if len(m.AlertTags) > 0 {
		for k, v := range m.AlertTags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdvisor(uint64(len(k))) + 1 + len(v) + sovAdvisor(uint64(len(v)))
			n += mapEntrySize + 1 + sovAdvisor(uint64(mapEntrySize))
		}
	}
	l = len(m.OverrideAnnotation)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	if len(m.ExpectedInbound) > 0 {
		for _, s := range m.ExpectedInbound {
			l = len(s)
			n += 1 + l + sovAdvisor(uint64(l))
		}
	}
	if len(m.ExpectedOutbound) > 0 {
		for _, s := range m.ExpectedOutbound {
			l = len(s)
			n += 1 + l + sovAdvisor(uint64(l))
		}
	}
	if len(m.SkipResource) > 0 {
		for _, s := range m.SkipResource {
			l = len(s)
			n += 1 + l + sovAdvisor(uint64(l))
		}
	}
	l = len(m.Severity)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	return n
}

func (m *AdvisorCheckConfigItem) Size() (n int) {
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Item)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	return n
}

func (m *AdvisorConfigDescriptor) Size() (n int) {
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Placeholder)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	return n
}

func (m *AdvisorModuleItem) Size() (n int) {
	var l int
	_ = l
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Item)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	return n
}

func (m *AdvisorResourceCheck) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Action)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Severity)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	if len(m.Requirements) > 0 {
		for _, s := range m.Requirements {
			l = len(s)
			n += 1 + l + sovAdvisor(uint64(l))
		}
	}
	l = len(m.Expected)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	if len(m.PreRequisites) > 0 {
		for _, s := range m.PreRequisites {
			l = len(s)
			n += 1 + l + sovAdvisor(uint64(l))
		}
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Recommendation)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	if len(m.References) > 0 {
		for _, s := range m.References {
			l = len(s)
			n += 1 + l + sovAdvisor(uint64(l))
		}
	}
	l = len(m.OverrideAnnotation)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	if len(m.SkipResource) > 0 {
		for _, s := range m.SkipResource {
			l = len(s)
			n += 1 + l + sovAdvisor(uint64(l))
		}
	}
	if len(m.Config) > 0 {
		for _, e := range m.Config {
			l = e.Size()
			n += 1 + l + sovAdvisor(uint64(l))
		}
	}
	if m.MandatoryConfigItems {
		n += 2
	}
	if m.ConfigDescriptor != nil {
		l = m.ConfigDescriptor.Size()
		n += 2 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 2 + l + sovAdvisor(uint64(l))
	}
	if len(m.CheckApplicability) > 0 {
		l = 0
		for _, e := range m.CheckApplicability {
			l += sovAdvisor(uint64(e))
		}
		n += 2 + sovAdvisor(uint64(l)) + l
	}
	return n
}

func (m *AdvisorResourceCheckGroup) Size() (n int) {
	var l int
	_ = l
	l = len(m.GroupID)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.ResourceSelector)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	if len(m.SkipResource) > 0 {
		for _, s := range m.SkipResource {
			l = len(s)
			n += 1 + l + sovAdvisor(uint64(l))
		}
	}
	if len(m.Checks) > 0 {
		for _, e := range m.Checks {
			l = e.Size()
			n += 1 + l + sovAdvisor(uint64(l))
		}
	}
	return n
}

func (m *AdvisorCheckModule) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovAdvisor(uint64(l))
		}
	}
	if len(m.PreRequisites) > 0 {
		for _, s := range m.PreRequisites {
			l = len(s)
			n += 1 + l + sovAdvisor(uint64(l))
		}
	}
	if m.ReportPassedChecks {
		n += 2
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovAdvisor(uint64(l))
		}
	}
	if len(m.ConfigItems) > 0 {
		for _, e := range m.ConfigItems {
			l = e.Size()
			n += 1 + l + sovAdvisor(uint64(l))
		}
	}
	return n
}

func (m *AdvisorPolicyScope) Size() (n int) {
	var l int
	_ = l
	l = len(m.NamespaceInclude)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.NamespaceExclude)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Clusters)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.ClustersExclude)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	return n
}

func (m *AdvisorValidationProfile) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.UID)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	if m.PricePlan != 0 {
		n += 1 + sovAdvisor(uint64(m.PricePlan))
	}
	l = len(m.ProfileID)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = m.Scope.Size()
	n += 1 + l + sovAdvisor(uint64(l))
	if m.ApplyOnAdmission {
		n += 2
	}
	if m.ApplyOnScan {
		n += 2
	}
	l = m.Policy.Size()
	n += 1 + l + sovAdvisor(uint64(l))
	if m.ProfileDefinition != nil {
		l = m.ProfileDefinition.Size()
		n += 2 + l + sovAdvisor(uint64(l))
	}
	return n
}

func (m *AdvisorTestConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.TestId)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Action)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Severity)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	if len(m.SkipResource) > 0 {
		for _, s := range m.SkipResource {
			l = len(s)
			n += 1 + l + sovAdvisor(uint64(l))
		}
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovAdvisor(uint64(l))
		}
	}
	return n
}

func (m *AdvisorProfileDef) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProfileName)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.TemplateId)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	if len(m.TestConfig) > 0 {
		for _, e := range m.TestConfig {
			l = e.Size()
			n += 1 + l + sovAdvisor(uint64(l))
		}
	}
	if m.Scope != nil {
		l = m.Scope.Size()
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.ProfileId)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.ModifiedBy)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	if m.ModificationDate != 0 {
		n += 1 + sovAdvisor(uint64(m.ModificationDate))
	}
	return n
}

func (m *AdvisorValidationPolicySpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Modules) > 0 {
		for _, e := range m.Modules {
			l = e.Size()
			n += 2 + l + sovAdvisor(uint64(l))
		}
	}
	return n
}

func (m *CheckResult) Size() (n int) {
	var l int
	_ = l
	l = len(m.CheckId)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Category)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Severity)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Action)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Recommendation)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	if len(m.References) > 0 {
		for _, s := range m.References {
			l = len(s)
			n += 1 + l + sovAdvisor(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdvisor(uint64(len(k))) + 1 + len(v) + sovAdvisor(uint64(len(v)))
			n += mapEntrySize + 1 + sovAdvisor(uint64(mapEntrySize))
		}
	}
	l = len(m.ResultUID)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.DeltaOp)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = m.Resource.Size()
	n += 1 + l + sovAdvisor(uint64(l))
	l = m.Check.Size()
	n += 1 + l + sovAdvisor(uint64(l))
	if len(m.AdditionalFindings) > 0 {
		for k, v := range m.AdditionalFindings {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovAdvisor(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovAdvisor(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovAdvisor(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ResourceInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 2 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 2 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Group)
	if l > 0 {
		n += 2 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 2 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 2 + l + sovAdvisor(uint64(l))
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdvisor(uint64(len(k))) + 1 + len(v) + sovAdvisor(uint64(len(v)))
			n += mapEntrySize + 2 + sovAdvisor(uint64(mapEntrySize))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdvisor(uint64(len(k))) + 1 + len(v) + sovAdvisor(uint64(len(v)))
			n += mapEntrySize + 2 + sovAdvisor(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *CheckInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.ModuleTitle)
	if l > 0 {
		n += 2 + l + sovAdvisor(uint64(l))
	}
	l = len(m.GroupTitle)
	if l > 0 {
		n += 2 + l + sovAdvisor(uint64(l))
	}
	l = len(m.CheckTitle)
	if l > 0 {
		n += 2 + l + sovAdvisor(uint64(l))
	}
	l = len(m.ModuleId)
	if l > 0 {
		n += 2 + l + sovAdvisor(uint64(l))
	}
	l = len(m.GroupId)
	if l > 0 {
		n += 2 + l + sovAdvisor(uint64(l))
	}
	l = len(m.CheckId)
	if l > 0 {
		n += 2 + l + sovAdvisor(uint64(l))
	}
	return n
}

func (m *AdditionalFinding) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Severity)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	if len(m.References) > 0 {
		for _, s := range m.References {
			l = len(s)
			n += 1 + l + sovAdvisor(uint64(l))
		}
	}
	if len(m.Info) > 0 {
		for k, v := range m.Info {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdvisor(uint64(len(k))) + 1 + len(v) + sovAdvisor(uint64(len(v)))
			n += mapEntrySize + 1 + sovAdvisor(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AdditionalFindings) Size() (n int) {
	var l int
	_ = l
	if len(m.SeverityCount) > 0 {
		for k, v := range m.SeverityCount {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdvisor(uint64(len(k))) + 1 + sovAdvisor(uint64(v))
			n += mapEntrySize + 1 + sovAdvisor(uint64(mapEntrySize))
		}
	}
	l = len(m.Severity)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	if len(m.Findings) > 0 {
		for _, e := range m.Findings {
			l = e.Size()
			n += 1 + l + sovAdvisor(uint64(l))
		}
	}
	return n
}

func (m *AdvisorReportHeader) Size() (n int) {
	var l int
	_ = l
	l = len(m.CreationTimeStamp)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.ReportUID)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.OrganizationUID)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.DataCenterUID)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.ClusterUID)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.KubernetesVersion)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Info)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.ScannerVersion)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	if m.MSTimeStamp != 0 {
		n += 1 + sovAdvisor(uint64(m.MSTimeStamp))
	}
	l = len(m.ProfileID)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	return n
}

func (m *AdvisorReportData) Size() (n int) {
	var l int
	_ = l
	l = len(m.ResourceName)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.ResourceNamespace)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.ResourceUID)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.ResourceKind)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.ServiceAccount)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.Fingerprint)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.SnapshotId)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	l = len(m.DeltaOp)
	if l > 0 {
		n += 1 + l + sovAdvisor(uint64(l))
	}
	if len(m.Images) > 0 {
		for _, s := range m.Images {
			l = len(s)
			n += 2 + l + sovAdvisor(uint64(l))
		}
	}
	if len(m.InitImages) > 0 {
		for _, s := range m.InitImages {
			l = len(s)
			n += 2 + l + sovAdvisor(uint64(l))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdvisor(uint64(len(k))) + 1 + len(v) + sovAdvisor(uint64(len(v)))
			n += mapEntrySize + 2 + sovAdvisor(uint64(mapEntrySize))
		}
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAdvisor(uint64(len(k))) + 1 + len(v) + sovAdvisor(uint64(len(v)))
			n += mapEntrySize + 2 + sovAdvisor(uint64(mapEntrySize))
		}
	}
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 2 + l + sovAdvisor(uint64(l))
		}
	}
	return n
}

func (m *AdvisorReport) Size() (n int) {
	var l int
	_ = l
	l = m.AdvisorReportHeader.Size()
	n += 1 + l + sovAdvisor(uint64(l))
	l = m.AdvisorReportData.Size()
	n += 1 + l + sovAdvisor(uint64(l))
	return n
}

func (m *AdvisorClusterReport) Size() (n int) {
	var l int
	_ = l
	l = m.AdvisorReportHeader.Size()
	n += 1 + l + sovAdvisor(uint64(l))
	if len(m.Reports) > 0 {
		for k, v := range m.Reports {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovAdvisor(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovAdvisor(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovAdvisor(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AdvisorClusterDiffReport) Size() (n int) {
	var l int
	_ = l
	l = m.PreviousReportHeader.Size()
	n += 1 + l + sovAdvisor(uint64(l))
	l = m.CurrentReportHeader.Size()
	n += 1 + l + sovAdvisor(uint64(l))
	if len(m.Reports) > 0 {
		for k, v := range m.Reports {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovAdvisor(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovAdvisor(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovAdvisor(uint64(mapEntrySize))
		}
	}
	return n
}

func sovAdvisor(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAdvisor(x uint64) (n int) {
	return sovAdvisor(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AdvisorCheckFeatureBool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvisorCheckFeatureBool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvisorCheckFeatureBool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlertTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AlertTags == nil {
				m.AlertTags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdvisor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdvisor
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAdvisor
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdvisor(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAdvisor
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AlertTags[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideAnnotation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OverrideAnnotation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expected", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Expected = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipResource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SkipResource = append(m.SkipResource, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Severity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvisor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvisorCheckFeatureStringSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvisorCheckFeatureStringSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvisorCheckFeatureStringSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlertTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AlertTags == nil {
				m.AlertTags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdvisor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdvisor
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAdvisor
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdvisor(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAdvisor
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AlertTags[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideAnnotation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OverrideAnnotation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expected", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expected = append(m.Expected, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipResource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SkipResource = append(m.SkipResource, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Severity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvisor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvisorHostPathRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvisorHostPathRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvisorHostPathRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvisor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvisorCheckFeatureAlcideRules) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvisorCheckFeatureAlcideRules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvisorCheckFeatureAlcideRules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlertTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AlertTags == nil {
				m.AlertTags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdvisor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdvisor
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAdvisor
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdvisor(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAdvisor
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AlertTags[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideAnnotation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OverrideAnnotation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedInbound", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpectedInbound = append(m.ExpectedInbound, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedOutbound", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpectedOutbound = append(m.ExpectedOutbound, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipResource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SkipResource = append(m.SkipResource, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Severity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvisor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvisorCheckConfigItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvisorCheckConfigItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvisorCheckConfigItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Item = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvisor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvisorConfigDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvisorConfigDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvisorConfigDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Placeholder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Placeholder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvisor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvisorModuleItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvisorModuleItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvisorModuleItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Item = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvisor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvisorResourceCheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvisorResourceCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvisorResourceCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Severity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requirements", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requirements = append(m.Requirements, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expected", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expected = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreRequisites", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreRequisites = append(m.PreRequisites, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recommendation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recommendation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field References", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.References = append(m.References, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverrideAnnotation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OverrideAnnotation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipResource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SkipResource = append(m.SkipResource, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = append(m.Config, AdvisorCheckConfigItem{})
			if err := m.Config[len(m.Config)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MandatoryConfigItems", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MandatoryConfigItems = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigDescriptor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigDescriptor == nil {
				m.ConfigDescriptor = &AdvisorConfigDescriptor{}
			}
			if err := m.ConfigDescriptor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType == 0 {
				var v CheckApplicabilityType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdvisor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (CheckApplicabilityType(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CheckApplicability = append(m.CheckApplicability, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdvisor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAdvisor
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v CheckApplicabilityType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (CheckApplicabilityType(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CheckApplicability = append(m.CheckApplicability, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckApplicability", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvisor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvisorResourceCheckGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvisorResourceCheckGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvisorResourceCheckGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceSelector", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceSelector = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipResource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SkipResource = append(m.SkipResource, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checks = append(m.Checks, AdvisorResourceCheck{})
			if err := m.Checks[len(m.Checks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvisor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvisorCheckModule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvisorCheckModule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvisorCheckModule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, AdvisorResourceCheckGroup{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreRequisites", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreRequisites = append(m.PreRequisites, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportPassedChecks", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReportPassedChecks = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, AdvisorModuleItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigItems = append(m.ConfigItems, AdvisorCheckConfigItem{})
			if err := m.ConfigItems[len(m.ConfigItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvisor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvisorPolicyScope) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvisorPolicyScope: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvisorPolicyScope: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceInclude", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamespaceInclude = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceExclude", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NamespaceExclude = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clusters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Clusters = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClustersExclude", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClustersExclude = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvisor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvisorValidationProfile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvisorValidationProfile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvisorValidationProfile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PricePlan", wireType)
			}
			m.PricePlan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PricePlan |= (PricePlanType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfileID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Scope.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyOnAdmission", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ApplyOnAdmission = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyOnScan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ApplyOnScan = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileDefinition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProfileDefinition == nil {
				m.ProfileDefinition = &AdvisorProfileDef{}
			}
			if err := m.ProfileDefinition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvisor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvisorTestConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvisorTestConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvisorTestConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Severity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipResource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SkipResource = append(m.SkipResource, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &AdvisorCheckConfigItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvisor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvisorProfileDef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvisorProfileDef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvisorProfileDef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemplateId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TemplateId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestConfig = append(m.TestConfig, &AdvisorTestConfig{})
			if err := m.TestConfig[len(m.TestConfig)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Scope == nil {
				m.Scope = &AdvisorPolicyScope{}
			}
			if err := m.Scope.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifiedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModifiedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModificationDate", wireType)
			}
			m.ModificationDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModificationDate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvisor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvisorValidationPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvisorValidationPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvisorValidationPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Modules = append(m.Modules, AdvisorCheckModule{})
			if err := m.Modules[len(m.Modules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvisor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Category", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Category = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Severity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recommendation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recommendation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field References", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.References = append(m.References, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdvisor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdvisor
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAdvisor
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdvisor(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAdvisor
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResultUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaOp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeltaOp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Resource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Check", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Check.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdditionalFindings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdditionalFindings == nil {
				m.AdditionalFindings = make(map[string]*AdditionalFindings)
			}
			var mapkey string
			var mapvalue *AdditionalFindings
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdvisor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdvisor
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthAdvisor
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthAdvisor
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AdditionalFindings{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdvisor(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAdvisor
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AdditionalFindings[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvisor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdvisor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdvisor
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAdvisor
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdvisor(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAdvisor
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdvisor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdvisor
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAdvisor
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdvisor(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAdvisor
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvisor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvisor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdditionalFinding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdditionalFinding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdditionalFinding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Severity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field References", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.References = append(m.References, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdvisor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdvisor
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAdvisor
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdvisor(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAdvisor
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Info[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvisor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdditionalFindings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdditionalFindings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdditionalFindings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeverityCount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SeverityCount == nil {
				m.SeverityCount = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdvisor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdvisor
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdvisor(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAdvisor
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SeverityCount[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Severity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Findings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Findings = append(m.Findings, &AdditionalFinding{})
			if err := m.Findings[len(m.Findings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvisor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvisorReportHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvisorReportHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvisorReportHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimeStamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreationTimeStamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrganizationUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrganizationUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataCenterUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataCenterUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KubernetesVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScannerVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScannerVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MSTimeStamp", wireType)
			}
			m.MSTimeStamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MSTimeStamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfileID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvisor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvisorReportData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvisorReportData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvisorReportData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceNamespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceAccount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fingerprint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fingerprint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SnapshotId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaOp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeltaOp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Images", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Images = append(m.Images, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitImages", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitImages = append(m.InitImages, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdvisor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdvisor
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAdvisor
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdvisor(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAdvisor
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdvisor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdvisor
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAdvisor
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdvisor(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAdvisor
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, CheckResult{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvisor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvisorReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvisorReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvisorReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvisorReportHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AdvisorReportHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvisorReportData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AdvisorReportData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvisor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvisorClusterReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvisorClusterReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvisorClusterReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvisorReportHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AdvisorReportHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reports == nil {
				m.Reports = make(map[string]*AdvisorReportData)
			}
			var mapkey string
			var mapvalue *AdvisorReportData
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdvisor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdvisor
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthAdvisor
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthAdvisor
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AdvisorReportData{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdvisor(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAdvisor
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Reports[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvisor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvisorClusterDiffReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvisor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvisorClusterDiffReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvisorClusterDiffReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousReportHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PreviousReportHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentReportHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CurrentReportHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvisor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reports == nil {
				m.Reports = make(map[string]*AdvisorReportData)
			}
			var mapkey string
			var mapvalue *AdvisorReportData
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdvisor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAdvisor
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvisor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthAdvisor
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthAdvisor
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AdvisorReportData{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdvisor(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthAdvisor
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Reports[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvisor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvisor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAdvisor(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAdvisor
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAdvisor
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAdvisor
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAdvisor
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAdvisor(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAdvisor = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAdvisor   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("advisor.proto", fileDescriptorAdvisor) }

var fileDescriptorAdvisor = []byte{
	// 4016 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5b, 0xcd, 0x6f, 0x1c, 0xc9,
	0x75, 0x67, 0xcf, 0x17, 0x87, 0x45, 0x91, 0x6a, 0x95, 0x28, 0xaa, 0x45, 0xc9, 0x9c, 0x76, 0x47,
	0xbb, 0x66, 0x18, 0x69, 0xb4, 0xa6, 0x15, 0x7b, 0x57, 0xda, 0xd5, 0x2e, 0x87, 0xa4, 0xcc, 0xd9,
	0xa5, 0xa4, 0x41, 0x53, 0xd2, 0x1a, 0xc1, 0xc6, 0x71, 0xb3, 0xfb, 0xcd, 0xb0, 0xc1, 0x9e, 0xae,
	0xd9, 0xea, 0x1a, 0x89, 0xb3, 0x88, 0x13, 0xc0, 0xd9, 0x4b, 0x00, 0xe7, 0x60, 0x23, 0x40, 0x92,
	0x43, 0x90, 0x5b, 0x72, 0x71, 0xfe, 0x83, 0xe4, 0x16, 0x04, 0x8a, 0xf3, 0x01, 0x1f, 0x9d, 0xcb,
	0x24, 0xd9, 0xa3, 0x8e, 0x93, 0x04, 0x08, 0xe0, 0x4b, 0x50, 0x1f, 0xdd, 0xd3, 0x3d, 0xd3, 0x94,
	0x22, 0xad, 0x11, 0xad, 0x61, 0xdf, 0xba, 0x5f, 0x55, 0xbd, 0xf7, 0xea, 0x7d, 0xfc, 0xde, 0xab,
	0xea, 0x19, 0xb4, 0xe0, 0x78, 0x8f, 0xfc, 0x88, 0xd0, 0x7a, 0x8f, 0x12, 0x46, 0xf0, 0xac, 0x7a,
	0x5d, 0xb9, 0xda, 0xf1, 0xd9, 0x61, 0xff, 0xa0, 0xee, 0x92, 0xee, 0xb5, 0x0e, 0xe9, 0x90, 0x6b,
	0x62, 0xfc, 0xa0, 0xdf, 0x16, 0x6f, 0xe2, 0x45, 0x3c, 0xc9, 0x75, 0xd6, 0xf7, 0x66, 0xd1, 0xf9,
	0x4d, 0xb9, 0x74, 0xeb, 0x10, 0xdc, 0xa3, 0xdb, 0xe0, 0xb0, 0x3e, 0x85, 0x06, 0x21, 0x01, 0x66,
	0xa8, 0xb2, 0xe9, 0x32, 0x9f, 0x84, 0x86, 0x66, 0x6a, 0x6b, 0x73, 0x8d, 0x8f, 0x46, 0xc3, 0xda,
	0xb7, 0x3c, 0x68, 0x3b, 0xfd, 0x80, 0xdd, 0xb0, 0x9c, 0x00, 0x28, 0xb3, 0xcc, 0x47, 0x4e, 0xe0,
	0x7b, 0x0e, 0x83, 0x1b, 0x16, 0x85, 0x8f, 0xfb, 0x3e, 0x05, 0xef, 0x0a, 0x7c, 0xfc, 0x8e, 0x18,
	0x34, 0x7f, 0xd7, 0x84, 0x8f, 0xdf, 0xf1, 0x20, 0x1c, 0xc8, 0x27, 0x27, 0x08, 0xc8, 0x63, 0xcb,
	0xf4, 0x88, 0x7b, 0xc3, 0xda, 0xf4, 0xba, 0x7e, 0x14, 0xf9, 0x24, 0x34, 0x1d, 0x21, 0xc2, 0xb2,
	0x95, 0x2c, 0xfc, 0x47, 0x1a, 0x9a, 0xdb, 0xe4, 0xcb, 0xef, 0x3b, 0x9d, 0xc8, 0x28, 0x98, 0xc5,
	0xb5, 0xf9, 0x8d, 0x6b, 0xf5, 0x78, 0xb7, 0x27, 0xe8, 0x5a, 0x4f, 0x56, 0xec, 0x84, 0x8c, 0x0e,
	0x1a, 0xb7, 0x46, 0xc3, 0xda, 0x0d, 0x21, 0x88, 0x39, 0x9d, 0xc8, 0x74, 0x18, 0x73, 0xdc, 0x43,
	0xf0, 0x4c, 0x46, 0x4c, 0xa1, 0x5a, 0x64, 0x42, 0xd7, 0x67, 0x0c, 0x3c, 0xf3, 0x60, 0x60, 0xb2,
	0x43, 0x30, 0x7b, 0x24, 0xf0, 0xdd, 0x81, 0xe9, 0x72, 0xbe, 0x91, 0x65, 0x8f, 0x35, 0xc0, 0x7f,
	0xae, 0x21, 0x7c, 0xef, 0x11, 0x50, 0xea, 0x7b, 0xb0, 0x19, 0x86, 0x84, 0x39, 0xc2, 0x24, 0x45,
	0x61, 0x92, 0xee, 0x68, 0x58, 0xf3, 0x13, 0x93, 0xa8, 0xbd, 0xf9, 0x6d, 0xd3, 0x49, 0x26, 0x9a,
	0xa4, 0x2d, 0x04, 0xb4, 0x09, 0xed, 0x9a, 0x70, 0xec, 0x47, 0xcc, 0x4c, 0x3c, 0x27, 0x64, 0xd6,
	0x9d, 0xc0, 0xf5, 0x3d, 0xa8, 0xfb, 0xe4, 0xda, 0xdb, 0x6d, 0xb9, 0xa3, 0xab, 0xa1, 0xd3, 0x85,
	0x5b, 0x57, 0xcc, 0xe8, 0xc8, 0xef, 0xc5, 0x06, 0x16, 0x36, 0xca, 0x51, 0x04, 0x7f, 0x07, 0x55,
	0x77, 0x8e, 0x7b, 0xe0, 0x32, 0xf0, 0x8c, 0x92, 0xa9, 0xad, 0x55, 0x1b, 0xdb, 0x4f, 0x87, 0xb5,
	0x84, 0x36, 0x1a, 0xd6, 0xae, 0x0b, 0xad, 0x6e, 0x13, 0x6a, 0x1e, 0x10, 0x12, 0x80, 0x13, 0xaa,
	0x6d, 0x5e, 0x31, 0xe1, 0xb8, 0x47, 0x21, 0x8a, 0x84, 0x82, 0xa0, 0x16, 0x70, 0x81, 0x7d, 0xb0,
	0xec, 0x84, 0x03, 0xfe, 0x81, 0x86, 0x4e, 0xed, 0x1f, 0xf9, 0x3d, 0x1b, 0x22, 0xd2, 0xa7, 0x2e,
	0x18, 0x65, 0xb3, 0x98, 0xec, 0x9d, 0xb3, 0xde, 0xef, 0x81, 0xeb, 0xb7, 0x07, 0x66, 0xc0, 0x77,
	0x47, 0xda, 0x26, 0x55, 0x13, 0x23, 0x6e, 0x6f, 0xb1, 0x09, 0x76, 0xe8, 0x47, 0x52, 0x6a, 0xdd,
	0xdc, 0x71, 0xdc, 0x43, 0xd3, 0x67, 0xd0, 0x35, 0xa3, 0x43, 0xd2, 0x0f, 0x3c, 0xb3, 0x4d, 0x78,
	0x60, 0x24, 0xab, 0xae, 0x1e, 0xf9, 0xa1, 0x77, 0x8d, 0x9b, 0x20, 0xea, 0x39, 0x2e, 0x88, 0x27,
	0xd3, 0xb2, 0x33, 0x2a, 0xe0, 0xef, 0x6b, 0xa8, 0xba, 0x0f, 0x8f, 0x80, 0xfa, 0x6c, 0x60, 0x54,
	0x84, 0x2f, 0x7a, 0xa3, 0x61, 0x2d, 0x48, 0x7c, 0xb1, 0xeb, 0x77, 0x0e, 0x4f, 0x8a, 0xce, 0x2d,
	0xea, 0x33, 0xdf, 0x75, 0x02, 0x19, 0x96, 0x7c, 0xa6, 0x7c, 0xba, 0x03, 0x9e, 0xdf, 0xef, 0xca,
	0xe7, 0x3d, 0xf2, 0x58, 0x3e, 0xb4, 0x9c, 0x28, 0x52, 0x8e, 0x15, 0x51, 0x67, 0xc6, 0x62, 0x2d,
	0x3b, 0xd1, 0x60, 0xe5, 0x6d, 0xb4, 0x98, 0x8d, 0x40, 0xac, 0xa3, 0xe2, 0x11, 0x0c, 0x64, 0xe6,
	0xd8, 0xfc, 0x11, 0x2f, 0xa1, 0xb2, 0x30, 0xad, 0x51, 0x10, 0x34, 0xf9, 0x72, 0xa3, 0xf0, 0xa6,
	0x66, 0x7d, 0x7f, 0x16, 0x5d, 0xca, 0x09, 0xec, 0x7d, 0x46, 0xfd, 0xb0, 0xb3, 0x0f, 0xec, 0x15,
	0x65, 0xe2, 0x0f, 0x73, 0x32, 0xf1, 0xfa, 0xb3, 0x32, 0x31, 0x51, 0xf8, 0x57, 0xe9, 0xa8, 0xd2,
	0x91, 0xe7, 0xc9, 0xaf, 0xd2, 0xf1, 0x17, 0x2c, 0x1d, 0x7f, 0xaa, 0xa1, 0xb3, 0x2a, 0xba, 0x77,
	0x49, 0xc4, 0x5a, 0x0e, 0x3b, 0xb4, 0xfb, 0x01, 0xe0, 0x23, 0x54, 0xe2, 0xcf, 0x2a, 0x07, 0x3f,
	0x1c, 0x0d, 0x6b, 0xfb, 0xa9, 0x58, 0xfb, 0xb9, 0xa5, 0x9f, 0x10, 0x82, 0xef, 0xa3, 0xaa, 0x0d,
	0x8e, 0x77, 0x2f, 0x0c, 0x06, 0x42, 0xc3, 0x6a, 0xe3, 0xcd, 0x97, 0x8f, 0x9d, 0x98, 0x93, 0xf5,
	0x17, 0x55, 0xb4, 0x9a, 0x93, 0xb8, 0x9b, 0x22, 0xe6, 0xf9, 0x26, 0xa3, 0x57, 0x84, 0x35, 0x7f,
	0x9c, 0x83, 0x35, 0x5f, 0x7f, 0x16, 0xd6, 0xa4, 0x54, 0xfe, 0x25, 0x46, 0x9b, 0x3e, 0x3a, 0x1d,
	0xe3, 0x42, 0x33, 0x3c, 0x20, 0xfd, 0x30, 0x06, 0x9d, 0x0f, 0x9e, 0x0e, 0x6b, 0x93, 0x43, 0x2f,
	0x1d, 0x3f, 0x93, 0x8c, 0xf0, 0x31, 0xd2, 0x63, 0xd2, 0xbd, 0x3e, 0x93, 0x72, 0x25, 0x0a, 0xed,
	0x3d, 0x1d, 0xd6, 0xa6, 0xc6, 0x5e, 0x5a, 0xf0, 0x14, 0xa7, 0x69, 0xf0, 0xab, 0x7c, 0xc1, 0xc0,
	0x6f, 0xf6, 0x17, 0x1c, 0xfc, 0xfe, 0x4c, 0x43, 0xcb, 0xe9, 0x74, 0xdb, 0x22, 0x61, 0xdb, 0xef,
	0x34, 0x19, 0x74, 0x71, 0x03, 0xcd, 0x6f, 0x43, 0xe4, 0x52, 0xbf, 0x97, 0x82, 0x07, 0x73, 0x34,
	0xac, 0x5d, 0x9a, 0x4c, 0x82, 0xd4, 0x34, 0xcb, 0x4e, 0x2f, 0xc2, 0x37, 0x51, 0x89, 0xf3, 0x92,
	0x72, 0x1b, 0x5f, 0x19, 0x0d, 0x6b, 0xbf, 0x36, 0xb9, 0x58, 0x4a, 0xec, 0x53, 0x99, 0x41, 0x7c,
	0xb6, 0x65, 0x8b, 0x45, 0xd6, 0xdf, 0x17, 0xc7, 0x87, 0x15, 0x31, 0x29, 0xe6, 0x4c, 0x28, 0x7e,
	0x80, 0xca, 0xf7, 0x7d, 0x16, 0x80, 0x52, 0xeb, 0xdd, 0xd1, 0xb0, 0x76, 0x33, 0xe1, 0xdc, 0xa2,
	0xa4, 0x07, 0x94, 0xf9, 0x10, 0x99, 0x19, 0xee, 0x19, 0x89, 0x42, 0x54, 0x64, 0x32, 0xce, 0xc5,
	0xb2, 0x25, 0x37, 0xfc, 0x3e, 0x2a, 0x3f, 0x1c, 0x1b, 0xaa, 0x71, 0x7d, 0x34, 0xac, 0xbd, 0x31,
	0xc9, 0x76, 0x90, 0xc7, 0x46, 0x58, 0xd4, 0x64, 0x70, 0xcc, 0x2c, 0x5b, 0xb2, 0xc0, 0x21, 0x9a,
	0x6f, 0x05, 0x8e, 0x0b, 0x87, 0x24, 0xf0, 0x80, 0x2a, 0x10, 0xd9, 0x1b, 0x0d, 0x6b, 0xbb, 0x09,
	0xc7, 0x9d, 0x90, 0x01, 0x95, 0x98, 0xa4, 0x78, 0xf3, 0xb0, 0x75, 0x95, 0xce, 0x90, 0x27, 0xa8,
	0x37, 0x66, 0x69, 0xd9, 0x69, 0x01, 0xf8, 0x4f, 0x34, 0x54, 0xba, 0x3f, 0xe8, 0x81, 0x38, 0x16,
	0xcc, 0x35, 0xbe, 0xa7, 0x8d, 0x86, 0xb5, 0xdf, 0xcb, 0xad, 0x58, 0x44, 0x38, 0xc7, 0x09, 0x78,
	0x40, 0xca, 0x26, 0x4e, 0xc6, 0x5b, 0x33, 0x64, 0xd0, 0x01, 0xaa, 0x5e, 0xba, 0x4e, 0x07, 0x6c,
	0xe8, 0xf8, 0x11, 0xa3, 0x83, 0x07, 0xf6, 0x9e, 0xa4, 0xda, 0xd0, 0x81, 0x63, 0xf9, 0xf8, 0x41,
	0xff, 0x00, 0xe2, 0xa4, 0x30, 0x95, 0xaa, 0x5c, 0xbe, 0xf9, 0x50, 0x0a, 0x22, 0xd4, 0xb2, 0x85,
	0x42, 0xd6, 0x0f, 0x35, 0x74, 0x46, 0x39, 0xf2, 0x0e, 0xf1, 0xfa, 0x01, 0xfc, 0xdc, 0xe2, 0xeb,
	0xad, 0x4c, 0x7c, 0xbd, 0x36, 0x1a, 0xd6, 0xbe, 0x3c, 0xb9, 0x38, 0xa7, 0xe2, 0x8a, 0xe8, 0xfa,
	0x4b, 0x84, 0x96, 0x94, 0x52, 0xf1, 0x2e, 0x44, 0x06, 0xe0, 0x45, 0x54, 0x68, 0x6e, 0xab, 0xec,
	0x29, 0x34, 0xb7, 0x79, 0xf2, 0xc8, 0x50, 0x53, 0xc9, 0x23, 0x23, 0x65, 0x5c, 0x37, 0x8b, 0xff,
	0x8f, 0x75, 0x33, 0x83, 0x3d, 0xa5, 0x57, 0x8d, 0x3d, 0xd8, 0x42, 0xa7, 0x6c, 0x29, 0xa0, 0x0b,
	0x21, 0x8b, 0x64, 0x51, 0xb0, 0x33, 0x34, 0xbc, 0x92, 0xea, 0x90, 0x45, 0xab, 0x98, 0xea, 0x6d,
	0x2f, 0xa3, 0x85, 0x16, 0x05, 0x31, 0x3d, 0xf2, 0x19, 0x44, 0xc6, 0xac, 0x60, 0x90, 0x25, 0x62,
	0x03, 0xcd, 0xde, 0x81, 0x28, 0x72, 0x3a, 0x60, 0xcc, 0x09, 0x06, 0xf1, 0x2b, 0x7e, 0x1d, 0x2d,
	0xda, 0xe0, 0x92, 0x6e, 0x17, 0x42, 0x59, 0x36, 0x0d, 0x24, 0x26, 0x4c, 0x50, 0xf1, 0x2a, 0x42,
	0x36, 0xb4, 0x81, 0x42, 0xe8, 0x42, 0x64, 0xcc, 0x0b, 0x21, 0x29, 0xca, 0x49, 0x75, 0xff, 0xd4,
	0x17, 0xa5, 0xee, 0x4f, 0x95, 0xc1, 0x85, 0x57, 0x5f, 0x06, 0x03, 0x54, 0x91, 0xc0, 0x64, 0x2c,
	0x8a, 0xf6, 0xad, 0x96, 0xdb, 0xbe, 0x8d, 0xeb, 0x49, 0xe3, 0x6b, 0x4f, 0x86, 0xb5, 0x99, 0xa7,
	0xc3, 0x5a, 0x59, 0x00, 0xd9, 0x68, 0x58, 0xb3, 0xd2, 0xd1, 0x25, 0x36, 0xe0, 0xbb, 0x13, 0x80,
	0x6d, 0x2b, 0x19, 0xf8, 0xbb, 0x68, 0xe9, 0x8e, 0x13, 0x0a, 0x54, 0x19, 0x8c, 0x79, 0x46, 0xc6,
	0x69, 0xd1, 0x2b, 0x37, 0x47, 0xc3, 0xda, 0x4e, 0xe2, 0xa2, 0xb6, 0x13, 0x44, 0x29, 0xec, 0x64,
	0x94, 0x04, 0x91, 0xf9, 0xf8, 0x10, 0xd8, 0xa1, 0x02, 0x5b, 0x09, 0xb0, 0xc2, 0x02, 0x91, 0xe9,
	0x50, 0x30, 0xbb, 0x31, 0x6b, 0xcb, 0xce, 0x15, 0x83, 0xf7, 0x90, 0x3e, 0x59, 0x82, 0x0c, 0xdd,
	0xd4, 0xd6, 0xe6, 0x37, 0xcc, 0xa9, 0x6d, 0x4f, 0xcc, 0xb3, 0xa7, 0x56, 0x62, 0x33, 0x8b, 0x7c,
	0x67, 0x44, 0xcc, 0x66, 0x70, 0xed, 0x0f, 0x35, 0x84, 0x85, 0x61, 0x36, 0x7b, 0xbd, 0xc0, 0x77,
	0x9d, 0x03, 0x3f, 0xe0, 0x19, 0x8f, 0xcd, 0xe2, 0xda, 0x62, 0xca, 0xd2, 0xd3, 0x53, 0x38, 0xde,
	0x36, 0xde, 0xe4, 0x96, 0x16, 0xa5, 0x2b, 0x2f, 0x36, 0x44, 0x10, 0x98, 0x4e, 0x7a, 0x95, 0xc9,
	0x06, 0x3d, 0x88, 0xea, 0x96, 0x9d, 0x23, 0xd4, 0x7a, 0x52, 0x40, 0x17, 0xf2, 0x80, 0xf2, 0x9b,
	0x94, 0xf4, 0x7b, 0x3c, 0x39, 0xc5, 0x43, 0x02, 0x99, 0xf1, 0xeb, 0x09, 0xb8, 0xb9, 0x8e, 0xf4,
	0x98, 0xcb, 0x3e, 0x04, 0xe0, 0x72, 0x4b, 0x0a, 0x04, 0xb5, 0xa7, 0xe8, 0xd3, 0x61, 0x5f, 0x7a,
	0xf5, 0x61, 0x7f, 0x13, 0x55, 0xc4, 0xee, 0x23, 0xd1, 0x8a, 0xce, 0x6f, 0x7c, 0x69, 0xd2, 0xff,
	0x19, 0x1b, 0x35, 0x4a, 0xdc, 0x15, 0xb6, 0x5a, 0x62, 0xfd, 0xa8, 0x84, 0x70, 0x3a, 0x3b, 0x64,
	0x35, 0x9c, 0xaa, 0x38, 0x58, 0x15, 0x72, 0x69, 0x38, 0xf1, 0x3c, 0xb6, 0x66, 0x31, 0x6d, 0xcd,
	0xef, 0xa2, 0x6a, 0x2b, 0x70, 0x18, 0x07, 0x1e, 0x55, 0x0e, 0x9c, 0xd1, 0xb0, 0xf6, 0xdb, 0x49,
	0x2a, 0xf0, 0x1a, 0x4d, 0x43, 0x60, 0x10, 0x9d, 0x54, 0x14, 0xc6, 0x33, 0x54, 0xd9, 0x8f, 0x98,
	0x4f, 0x54, 0x81, 0x0f, 0x1d, 0xe6, 0x3f, 0x8a, 0x33, 0x29, 0x96, 0x63, 0xd9, 0x89, 0x48, 0xfc,
	0x1e, 0xaa, 0x08, 0x6f, 0x4b, 0xe4, 0x9f, 0xdf, 0xb0, 0x9e, 0x69, 0x0c, 0x31, 0x35, 0xb6, 0x88,
	0x5c, 0x37, 0x5d, 0x01, 0x2a, 0x79, 0x15, 0xa0, 0x8e, 0xb0, 0x0d, 0x3d, 0x42, 0x19, 0xaf, 0x4a,
	0xe0, 0x29, 0x07, 0xf0, 0xde, 0xbb, 0x6a, 0xe7, 0x8c, 0xe0, 0x26, 0x92, 0x20, 0x63, 0x54, 0x85,
	0x5a, 0x2b, 0x93, 0x6a, 0x8d, 0xbb, 0x90, 0xc6, 0xf9, 0x49, 0x54, 0xaa, 0x88, 0xdd, 0x5a, 0xb6,
	0x24, 0xe0, 0x4f, 0xd0, 0x7c, 0x1a, 0x6f, 0xe6, 0xfe, 0x6f, 0x58, 0xf7, 0x0d, 0xc5, 0x35, 0xbd,
	0x76, 0x34, 0xac, 0xa5, 0xeb, 0xe9, 0x37, 0x03, 0x72, 0xe0, 0x04, 0x93, 0x78, 0x97, 0x5e, 0x60,
	0x0d, 0x8b, 0x49, 0xb8, 0xb4, 0x44, 0x1d, 0xd9, 0x77, 0x49, 0x0f, 0xf0, 0x00, 0xe9, 0x77, 0xe3,
	0x20, 0x6d, 0x86, 0x6e, 0xd0, 0xf7, 0xe2, 0x36, 0xf8, 0xce, 0x68, 0x58, 0x6b, 0x26, 0xce, 0x5f,
	0x4f, 0x30, 0xb0, 0xdb, 0x75, 0xcc, 0x08, 0x7a, 0x0e, 0x75, 0xf8, 0x69, 0x2b, 0x89, 0xf0, 0x28,
	0x55, 0x78, 0xe2, 0x9c, 0x38, 0x00, 0x09, 0x0d, 0xe0, 0x59, 0xf6, 0x94, 0x18, 0xfc, 0x49, 0x4a,
	0xf4, 0xce, 0xb1, 0x14, 0x2d, 0x7b, 0xaf, 0xbb, 0xa3, 0x61, 0xed, 0xfd, 0x54, 0x95, 0x7c, 0x39,
	0xd1, 0x20, 0x79, 0x66, 0x64, 0x2b, 0x39, 0xf8, 0x3b, 0xa8, 0xba, 0x15, 0xf4, 0x23, 0x06, 0x34,
	0x52, 0xb1, 0xbe, 0x3d, 0x1a, 0xd6, 0xde, 0x7b, 0xee, 0x76, 0x5d, 0xb9, 0xc8, 0xec, 0xfb, 0x5e,
	0x94, 0xb7, 0xcb, 0x84, 0x2b, 0x26, 0xe8, 0x74, 0xfc, 0x1c, 0x6f, 0xae, 0x2c, 0x04, 0xed, 0x8c,
	0x86, 0xb5, 0xcd, 0x97, 0x15, 0x34, 0xde, 0xd3, 0x24, 0x77, 0xeb, 0xc7, 0x65, 0x64, 0x28, 0x07,
	0x3f, 0x4c, 0xcc, 0xd1, 0xa2, 0xa4, 0xed, 0x07, 0xc0, 0x51, 0x80, 0xdb, 0x40, 0xe1, 0x82, 0x78,
	0xe6, 0x47, 0xbb, 0x07, 0xcd, 0x6d, 0x05, 0x0c, 0xfc, 0x71, 0xb2, 0x96, 0x14, 0xa7, 0x6b, 0x89,
	0x81, 0x66, 0x1f, 0x02, 0xe5, 0xed, 0xa4, 0x34, 0x9b, 0x1d, 0xbf, 0xe2, 0xeb, 0x68, 0xae, 0x45,
	0x7d, 0x17, 0x5a, 0x81, 0x13, 0x8a, 0x9d, 0x2e, 0x6e, 0x2c, 0x27, 0x91, 0x9d, 0x8c, 0x70, 0xf8,
	0xb1, 0xc7, 0x13, 0xf1, 0x25, 0xbe, 0x4a, 0xa8, 0xd8, 0xdc, 0x56, 0x1d, 0xdd, 0x98, 0x80, 0x6f,
	0xa2, 0xb2, 0x88, 0x52, 0xd1, 0x89, 0xcd, 0x6f, 0x5c, 0x9c, 0xcc, 0x94, 0x54, 0x20, 0x37, 0xaa,
	0x3c, 0x4b, 0x7e, 0xc2, 0xe1, 0x40, 0xae, 0xc1, 0x7f, 0xa0, 0x21, 0x9d, 0x17, 0x9f, 0xc1, 0xbd,
	0x30, 0xe9, 0x81, 0x8d, 0x79, 0x51, 0xe2, 0xb3, 0xf7, 0x6f, 0x8c, 0xf6, 0x21, 0x8e, 0x31, 0xc9,
	0x71, 0xda, 0xb3, 0x26, 0x09, 0x13, 0x68, 0x37, 0x9d, 0xa4, 0xa5, 0x66, 0x44, 0xf6, 0x00, 0xd2,
	0x15, 0x96, 0x3d, 0x25, 0x10, 0x7b, 0x68, 0x5e, 0xd1, 0xf6, 0x5d, 0x47, 0x76, 0x81, 0xd5, 0x46,
	0x63, 0x34, 0xac, 0xdd, 0x7a, 0x61, 0xf9, 0x71, 0x48, 0x44, 0xae, 0xc3, 0x93, 0x3b, 0xc5, 0x16,
	0x7f, 0xaa, 0xa1, 0x8a, 0x5c, 0x6a, 0x2c, 0x08, 0x53, 0x5d, 0x9e, 0x34, 0x55, 0x2a, 0x24, 0xa4,
	0xd1, 0x7a, 0xe0, 0x36, 0x6e, 0xab, 0xda, 0xfe, 0x79, 0x75, 0x51, 0xb2, 0xf1, 0x2e, 0x3a, 0xd3,
	0x93, 0xce, 0xdb, 0x86, 0xb6, 0x1f, 0xfa, 0x22, 0x8a, 0x96, 0x84, 0x42, 0x53, 0xb0, 0xd9, 0x4a,
	0x26, 0xda, 0xd3, 0x8b, 0xac, 0x9f, 0x15, 0x93, 0x53, 0xde, 0x7d, 0x88, 0x98, 0x6a, 0xdc, 0x96,
	0x51, 0x85, 0xbf, 0x35, 0x3d, 0x15, 0xc7, 0xea, 0x2d, 0x75, 0x7e, 0x2a, 0xbc, 0xaa, 0xf3, 0x53,
	0xf1, 0x95, 0x9f, 0x9f, 0xbe, 0x88, 0x0d, 0xce, 0x6f, 0xa2, 0xb2, 0x68, 0x8c, 0x55, 0x49, 0x7f,
	0x5e, 0xa9, 0xb3, 0xe5, 0x6c, 0xde, 0x25, 0x9e, 0x99, 0x0a, 0x13, 0x8e, 0x4e, 0x2a, 0x50, 0x52,
	0x50, 0x96, 0x26, 0xf1, 0xa3, 0x19, 0x83, 0x6e, 0x2f, 0x70, 0x18, 0x34, 0x3d, 0x05, 0x6c, 0x29,
	0x0a, 0xbe, 0xc1, 0xc7, 0xe3, 0x68, 0x32, 0x8a, 0xf9, 0xf5, 0x7c, 0x1c, 0x6f, 0x76, 0x6a, 0x36,
	0xfe, 0x6a, 0x8c, 0x45, 0xa5, 0xe7, 0x62, 0x51, 0x8c, 0x40, 0x97, 0xd0, 0x9c, 0xd2, 0xae, 0xe9,
	0x49, 0xf0, 0xb7, 0xc7, 0x04, 0xae, 0x6c, 0x97, 0x78, 0x7e, 0xdb, 0x07, 0xaf, 0xa1, 0x3e, 0x7c,
	0xd8, 0x29, 0x0a, 0x87, 0x5a, 0x08, 0x9d, 0x83, 0x00, 0x3c, 0xd5, 0x9c, 0xc4, 0xaf, 0xbc, 0xed,
	0x95, 0xf3, 0x5c, 0x91, 0xd0, 0xdb, 0x0e, 0x03, 0xa3, 0x6a, 0x6a, 0x6b, 0x45, 0x7b, 0x8a, 0x6e,
	0x7d, 0x1b, 0x5d, 0x7c, 0x06, 0x02, 0xe0, 0x77, 0xd1, 0xac, 0xec, 0x5f, 0x22, 0x63, 0x43, 0x98,
	0xe3, 0x62, 0xae, 0x8b, 0xe4, 0x9c, 0x14, 0xc6, 0xc6, 0xab, 0xac, 0x7f, 0x2b, 0xa3, 0x79, 0x31,
	0xc5, 0x86, 0xa8, 0x1f, 0x30, 0xae, 0xb5, 0x78, 0x4d, 0x72, 0x34, 0x7e, 0xe5, 0x67, 0xf7, 0x2d,
	0x87, 0x41, 0x87, 0xd0, 0x81, 0x72, 0x4d, 0xf2, 0xce, 0xc7, 0xb2, 0x99, 0x94, 0x8a, 0xeb, 0xe5,
	0x24, 0xb9, 0x65, 0xc5, 0x89, 0xd3, 0x2f, 0x75, 0x92, 0x2f, 0x3f, 0xef, 0x24, 0x5f, 0xc9, 0x3d,
	0xc9, 0xf3, 0x02, 0x48, 0x03, 0x79, 0xed, 0x6a, 0xf3, 0x47, 0xae, 0x47, 0xd2, 0x02, 0x57, 0xa5,
	0x1e, 0x49, 0x7f, 0x9a, 0x3d, 0xf7, 0xcf, 0x4d, 0x9d, 0xfb, 0x37, 0x50, 0x49, 0x7c, 0x80, 0x40,
	0xc2, 0x8e, 0xab, 0xd9, 0x73, 0x95, 0xb4, 0x4e, 0x3d, 0xb9, 0x57, 0xb5, 0xc5, 0x5c, 0x1e, 0x21,
	0x72, 0x84, 0x17, 0xe2, 0x79, 0x19, 0x21, 0x09, 0x81, 0xef, 0x70, 0x1b, 0x02, 0xe6, 0xdc, 0xeb,
	0xc9, 0xdb, 0x03, 0x3b, 0x7e, 0xc5, 0x37, 0x51, 0x35, 0x75, 0x7c, 0xe7, 0xf1, 0x78, 0x2e, 0x91,
	0x17, 0x0f, 0x34, 0xc3, 0x36, 0x49, 0x79, 0x2c, 0x59, 0x80, 0x37, 0x50, 0x59, 0xe8, 0x64, 0x2c,
	0x8a, 0x95, 0x38, 0xab, 0xe9, 0xc4, 0x32, 0x39, 0x15, 0x7f, 0xc4, 0x9b, 0x47, 0xcf, 0x97, 0x57,
	0x7d, 0xb7, 0xfd, 0xd0, 0xf3, 0xc3, 0x0e, 0x3f, 0x30, 0xf3, 0xad, 0x5e, 0xc9, 0xdd, 0xea, 0xf4,
	0x74, 0xb9, 0xf1, 0x1c, 0x3e, 0x2b, 0xdf, 0x40, 0x73, 0x2f, 0x75, 0xe3, 0xbc, 0x72, 0x80, 0xce,
	0x9f, 0x20, 0x27, 0x87, 0xcd, 0x57, 0xd3, 0x6c, 0xb2, 0x91, 0x3e, 0xc9, 0x22, 0x7d, 0xab, 0xfd,
	0x69, 0x11, 0x9d, 0x4a, 0xdb, 0x94, 0xf7, 0x52, 0x1f, 0xf8, 0xa1, 0x27, 0x0a, 0xdb, 0x9c, 0x2d,
	0x9e, 0xd3, 0x7d, 0xd1, 0xb9, 0x6c, 0x5f, 0xb4, 0x84, 0xca, 0xe2, 0x78, 0x62, 0x2c, 0x4b, 0xe5,
	0xe5, 0x49, 0x37, 0xee, 0xc7, 0xce, 0xa7, 0xfa, 0xb1, 0x4b, 0x68, 0x2e, 0xe9, 0x53, 0x0d, 0x43,
	0x06, 0x43, 0x42, 0xc0, 0xbb, 0x68, 0x7e, 0x7c, 0x89, 0x13, 0x19, 0x17, 0x84, 0xe9, 0x5f, 0xcf,
	0xf5, 0x7a, 0x3d, 0x35, 0x51, 0x1a, 0x3d, 0xbd, 0x14, 0xbf, 0x85, 0x2a, 0x7b, 0xce, 0x01, 0x04,
	0x91, 0xb1, 0x22, 0x98, 0x7c, 0x39, 0x9f, 0x89, 0x9c, 0x23, 0xd7, 0xab, 0x05, 0x2b, 0xb7, 0x90,
	0x3e, 0xc9, 0xfb, 0x85, 0xfc, 0xf5, 0x16, 0x9a, 0x4f, 0xb1, 0x7d, 0xa1, 0x8f, 0x0b, 0x7f, 0xab,
	0xa1, 0xb9, 0x24, 0x40, 0x79, 0x2d, 0x90, 0x08, 0x24, 0xcf, 0xb1, 0xd2, 0x15, 0x69, 0x12, 0x4f,
	0x57, 0x61, 0x6a, 0x39, 0x41, 0x3a, 0x25, 0x45, 0xe1, 0xe3, 0x82, 0x9d, 0x1c, 0x97, 0xce, 0x49,
	0x51, 0x38, 0x14, 0xa8, 0x93, 0x9d, 0xa7, 0xbc, 0x94, 0xbc, 0x8f, 0xef, 0x29, 0x3c, 0xe5, 0xa7,
	0xf8, 0x35, 0x0d, 0x7f, 0x17, 0x32, 0xf0, 0xc7, 0xcf, 0x5f, 0x67, 0xa6, 0x02, 0x0d, 0x5f, 0x47,
	0x85, 0x18, 0x29, 0x1b, 0x97, 0xc5, 0xa1, 0x6e, 0xf2, 0x8b, 0xc6, 0xc3, 0x9d, 0xab, 0xc7, 0xc7,
	0xc7, 0x57, 0x07, 0x83, 0xc1, 0x95, 0x7a, 0xbd, 0x6e, 0xd9, 0x85, 0xa6, 0x87, 0xdf, 0xc8, 0xdc,
	0x86, 0x34, 0x56, 0x46, 0xc3, 0xda, 0xf2, 0xe4, 0xc2, 0xfb, 0x99, 0x6f, 0x11, 0x8d, 0x9c, 0xce,
	0xfe, 0x45, 0xef, 0xc7, 0x6f, 0x4c, 0x5d, 0x17, 0xaf, 0x8e, 0x86, 0xb5, 0x95, 0x49, 0x06, 0xf1,
	0x1c, 0x33, 0xdd, 0x9c, 0xec, 0x66, 0xc0, 0x53, 0x7e, 0xef, 0x5b, 0x1b, 0x0d, 0x6b, 0x97, 0x27,
	0x57, 0x3f, 0xb0, 0xf7, 0xcc, 0x64, 0xa6, 0xb9, 0x49, 0xa9, 0x33, 0xb0, 0x32, 0x30, 0xfb, 0x6d,
	0x54, 0xe2, 0x11, 0xa0, 0x6e, 0x4c, 0x2e, 0x9f, 0x9c, 0xc4, 0x75, 0x3e, 0x4d, 0x7e, 0xd5, 0xcd,
	0xb5, 0xec, 0x78, 0x81, 0xc9, 0x67, 0x5a, 0xb6, 0xe0, 0xcb, 0xb1, 0x28, 0x59, 0xf8, 0x42, 0x01,
	0xfa, 0xaf, 0x85, 0x3c, 0x8c, 0xc4, 0xbf, 0x8f, 0x16, 0x62, 0x2b, 0x6c, 0x91, 0x7e, 0xc8, 0x0c,
	0x4d, 0x28, 0x5e, 0x7f, 0x06, 0xfa, 0xd4, 0x33, 0x0b, 0xe4, 0x16, 0x7e, 0x7d, 0x34, 0xac, 0xbd,
	0x76, 0xa2, 0xa9, 0x19, 0x61, 0x4e, 0x60, 0xba, 0x7c, 0xba, 0x65, 0x67, 0xe5, 0xe1, 0xdd, 0x94,
	0xdb, 0x64, 0xbc, 0x5c, 0x19, 0x0d, 0x6b, 0x6b, 0x09, 0x2f, 0xb1, 0x79, 0x65, 0x92, 0x4e, 0x87,
	0x42, 0x47, 0x9c, 0x3f, 0xf3, 0x3a, 0xcc, 0xaf, 0xa3, 0x6a, 0x02, 0xfd, 0xd3, 0xcd, 0xd3, 0xc4,
	0x2e, 0xec, 0x64, 0xee, 0xca, 0x7b, 0x08, 0x4f, 0xef, 0xe8, 0x79, 0xb6, 0x2d, 0xa7, 0x6d, 0xfb,
	0xb3, 0x42, 0xf2, 0xb3, 0x0a, 0x79, 0x43, 0xb3, 0x0b, 0x8e, 0x07, 0x14, 0x5f, 0x41, 0x67, 0xb6,
	0x28, 0x08, 0x34, 0xba, 0xef, 0x77, 0x61, 0x9f, 0x39, 0xdd, 0x9e, 0xe2, 0x38, 0x3d, 0x20, 0xab,
	0x2d, 0x5f, 0x3d, 0x3e, 0xf6, 0x8e, 0x09, 0x78, 0x0d, 0x9d, 0xbe, 0x47, 0x3b, 0x4e, 0xe8, 0x7f,
	0x22, 0x96, 0xf1, 0x39, 0xb2, 0x15, 0x99, 0x24, 0xe3, 0xcb, 0x68, 0x61, 0xdb, 0x61, 0xce, 0x16,
	0x84, 0x0c, 0x28, 0x9f, 0x27, 0x1b, 0x93, 0x2c, 0x51, 0x00, 0x8c, 0x3c, 0x25, 0xf1, 0x29, 0x65,
	0x05, 0x30, 0x09, 0x85, 0xeb, 0x3e, 0xbe, 0x2f, 0x8b, 0x8b, 0x87, 0x6c, 0x54, 0xa6, 0x07, 0x78,
	0xc1, 0x10, 0x61, 0x2f, 0x9b, 0x15, 0xf1, 0xcc, 0xfb, 0x1c, 0x7e, 0xfa, 0x0b, 0x81, 0xc6, 0xcb,
	0x65, 0xcf, 0x32, 0x41, 0x15, 0x60, 0xb9, 0x3f, 0xb6, 0xcf, 0x9c, 0x68, 0x15, 0xd3, 0xa4, 0xec,
	0x31, 0x1c, 0x4d, 0x1c, 0xc3, 0xad, 0xbf, 0x2a, 0x27, 0xed, 0xb8, 0x34, 0x17, 0xdf, 0xa8, 0xfc,
	0x5e, 0x23, 0xeb, 0x45, 0xaa, 0x1f, 0xcf, 0xd0, 0xf8, 0x1e, 0xd3, 0xef, 0xb2, 0xb4, 0x49, 0xcb,
	0x4f, 0x0f, 0x70, 0x3d, 0x63, 0xe2, 0xd8, 0xfa, 0x69, 0x52, 0x5a, 0xa6, 0x28, 0xc1, 0xa5, 0xac,
	0x4c, 0x51, 0x8a, 0xb9, 0x55, 0x80, 0x3e, 0xf2, 0x5d, 0xd8, 0x74, 0x45, 0x46, 0x28, 0xdb, 0x4f,
	0x50, 0xb9, 0xb4, 0xdb, 0x7e, 0xd8, 0x01, 0xda, 0xa3, 0x7e, 0xc8, 0x94, 0xe5, 0xd3, 0x24, 0xee,
	0xc1, 0xfd, 0xd0, 0xe9, 0x45, 0x87, 0x84, 0x1f, 0x39, 0xa5, 0xe5, 0x53, 0x94, 0x74, 0x7f, 0x56,
	0xcd, 0xf6, 0x67, 0xcb, 0xa8, 0x22, 0x3e, 0x79, 0x46, 0x86, 0x2e, 0xfa, 0x44, 0xf5, 0xc6, 0x39,
	0x36, 0x43, 0x9f, 0xa9, 0xb1, 0x33, 0xb2, 0x87, 0x1c, 0x53, 0xf0, 0xad, 0xa4, 0x34, 0xe3, 0x89,
	0xfa, 0x3e, 0x65, 0xff, 0xbc, 0xfa, 0x8c, 0xef, 0x64, 0x9b, 0x84, 0xb3, 0x82, 0xc9, 0x6f, 0x3c,
	0x83, 0xc9, 0xb3, 0x3b, 0x85, 0xeb, 0x68, 0x56, 0x76, 0x73, 0x91, 0xb1, 0x24, 0x58, 0x2d, 0xe5,
	0xb5, 0x7a, 0xea, 0x16, 0x36, 0x9e, 0xfa, 0x39, 0x8a, 0xfc, 0xe7, 0xed, 0x2f, 0xac, 0x1f, 0x68,
	0x68, 0x21, 0xb3, 0x49, 0xdc, 0x40, 0x15, 0x89, 0x15, 0x82, 0xc1, 0xfc, 0xc6, 0xa5, 0x7c, 0x63,
	0xc8, 0x39, 0x8d, 0x53, 0xaa, 0xef, 0xd5, 0x46, 0xe2, 0x5e, 0x59, 0xa1, 0xcc, 0xdb, 0xa8, 0xc4,
	0x8d, 0xa5, 0xfa, 0xc6, 0x95, 0x93, 0xcd, 0x39, 0xb1, 0x5e, 0xac, 0xb2, 0xfe, 0xb4, 0x90, 0x7c,
	0x1b, 0x56, 0xd9, 0xaf, 0x54, 0xfb, 0x28, 0x17, 0xd3, 0x5e, 0x42, 0xcf, 0x5c, 0x68, 0x7c, 0x9f,
	0xfb, 0x8e, 0xbf, 0xc7, 0x3f, 0x89, 0x5a, 0x9f, 0x3a, 0xd9, 0xa5, 0xb5, 0xa9, 0xab, 0xc9, 0xb2,
	0xda, 0x94, 0x46, 0xca, 0xa3, 0x82, 0xb6, 0xf2, 0x90, 0xa7, 0xdd, 0x78, 0x38, 0xc7, 0x25, 0x6f,
	0x64, 0x7b, 0xeb, 0x67, 0xd8, 0x28, 0xed, 0xae, 0xff, 0x29, 0x24, 0x57, 0x96, 0x4a, 0x99, 0x6d,
	0xbf, 0xdd, 0x56, 0xe6, 0xf9, 0x2d, 0xb4, 0xd4, 0xa2, 0xf0, 0xc8, 0x27, 0xfd, 0xe8, 0x85, 0xed,
	0x53, 0x55, 0x17, 0x5b, 0x33, 0x76, 0x2e, 0x0f, 0xfc, 0x2d, 0x74, 0x76, 0xab, 0x4f, 0x29, 0x84,
	0x2c, 0xc3, 0xba, 0xf0, 0x42, 0xac, 0xf3, 0x58, 0xe0, 0xbb, 0x63, 0xb3, 0x17, 0xa7, 0x0a, 0x7d,
	0xfe, 0x4e, 0x5f, 0x85, 0xe9, 0xd7, 0x5f, 0x1b, 0x9f, 0x74, 0xf1, 0x22, 0x42, 0xe3, 0x82, 0xa3,
	0xcf, 0xe0, 0x39, 0x54, 0x16, 0x5f, 0x6e, 0x74, 0x6d, 0xfd, 0x3f, 0x4b, 0x49, 0x43, 0x8b, 0x97,
	0x11, 0x7e, 0x10, 0x46, 0xf2, 0xdb, 0xaa, 0xfa, 0x3a, 0xd2, 0xf4, 0xf4, 0x19, 0x4e, 0xdf, 0x22,
	0x21, 0x73, 0xfc, 0x10, 0xe4, 0x6d, 0x41, 0xc3, 0x89, 0x40, 0xf7, 0xf0, 0x25, 0x64, 0x64, 0xe9,
	0x2d, 0xea, 0x3f, 0xf2, 0x03, 0xbf, 0x03, 0x9e, 0x0e, 0xf8, 0x22, 0x3a, 0x9f, 0x1d, 0xb5, 0xfb,
	0xe1, 0x66, 0x64, 0x13, 0xc2, 0xf4, 0x36, 0x36, 0xd1, 0xa5, 0x89, 0x41, 0xf5, 0x2b, 0x44, 0x3e,
	0x7e, 0x7b, 0x5f, 0xef, 0xe0, 0x15, 0xb4, 0x9c, 0x9d, 0x21, 0x10, 0xf4, 0xbe, 0xd3, 0xd1, 0x43,
	0xbc, 0x8a, 0x56, 0x92, 0x31, 0x2e, 0xd3, 0x61, 0xb0, 0x45, 0xc1, 0x0b, 0x99, 0xef, 0x04, 0x91,
	0x7e, 0x3c, 0xcd, 0x5d, 0xac, 0xfd, 0xf0, 0xd0, 0x67, 0xb0, 0xe7, 0x47, 0x4c, 0x27, 0xd8, 0x40,
	0x67, 0x5b, 0x44, 0x6e, 0x71, 0x97, 0x44, 0xec, 0x2e, 0xb0, 0xc7, 0x84, 0x1e, 0xe9, 0x4f, 0x34,
	0xbc, 0x84, 0x4e, 0xa7, 0x47, 0x5a, 0xcd, 0x6d, 0xfd, 0x1f, 0xa6, 0xa8, 0xcd, 0xd6, 0x96, 0xfe,
	0x63, 0x4d, 0x71, 0xd9, 0x0c, 0x02, 0xf2, 0x18, 0xbc, 0xf8, 0xe7, 0xa0, 0x91, 0xfe, 0x8f, 0x1a,
	0x5e, 0x41, 0xe7, 0x5a, 0xc4, 0xbb, 0x4d, 0xe8, 0x81, 0xef, 0x79, 0x10, 0x8e, 0xc7, 0xfe, 0x49,
	0x4b, 0xcb, 0x4e, 0x61, 0xa1, 0xfe, 0xcf, 0x1a, 0x3e, 0x8b, 0x16, 0xe3, 0x11, 0x09, 0xb0, 0xfa,
	0xbf, 0x68, 0xf8, 0x22, 0x5a, 0xfe, 0x90, 0xd0, 0xa3, 0x80, 0x38, 0xde, 0x4e, 0xf7, 0x00, 0x3c,
	0x0f, 0x3c, 0x79, 0xbf, 0xa3, 0xff, 0xa8, 0x80, 0x4d, 0x74, 0x31, 0x7f, 0x50, 0xfc, 0xf8, 0x51,
	0xff, 0xeb, 0x02, 0x5e, 0x45, 0x17, 0x36, 0x7b, 0x3e, 0x2f, 0x8d, 0x40, 0xf7, 0xc1, 0xa5, 0xc0,
	0xb8, 0xa9, 0x37, 0x5d, 0x17, 0xa2, 0x48, 0xff, 0xaf, 0x22, 0xfe, 0x12, 0x32, 0x92, 0x71, 0x2e,
	0x9c, 0x37, 0x55, 0xa0, 0x86, 0xff, 0xbb, 0x88, 0xcf, 0x21, 0xbd, 0x45, 0x3c, 0x65, 0x1f, 0x25,
	0xf7, 0xa7, 0x25, 0x2e, 0x57, 0x5e, 0x9b, 0xdd, 0x71, 0x7a, 0xd1, 0xb4, 0x0b, 0xfe, 0xa6, 0xcc,
	0xd5, 0x6e, 0x86, 0x1d, 0x0a, 0x51, 0x24, 0xcf, 0x5c, 0xbc, 0x5a, 0x88, 0xdb, 0x2d, 0xfd, 0xd3,
	0xd9, 0xf5, 0xdf, 0x41, 0x0b, 0x82, 0x9a, 0x74, 0x9e, 0xe7, 0xd1, 0xd9, 0x54, 0xe8, 0xc5, 0x64,
	0x7d, 0x06, 0x57, 0x51, 0xa9, 0xe5, 0x44, 0x91, 0xae, 0xe1, 0x59, 0x54, 0xdc, 0x23, 0x8f, 0xf5,
	0x02, 0x46, 0xa8, 0x22, 0x2f, 0x51, 0xf5, 0x22, 0x1f, 0xde, 0xf5, 0x3b, 0x87, 0x7a, 0x09, 0x9f,
	0x42, 0xd5, 0xf8, 0xca, 0x55, 0x2f, 0xaf, 0xef, 0xa2, 0xd3, 0xc9, 0xbd, 0xae, 0xba, 0x4e, 0x3a,
	0x87, 0xce, 0xa4, 0x44, 0x48, 0xa2, 0xcc, 0x05, 0xf1, 0x8b, 0x38, 0x5d, 0xe3, 0xcc, 0xb6, 0x21,
	0x1c, 0xe8, 0x05, 0x49, 0x0c, 0xc8, 0x63, 0xbd, 0xb8, 0xfe, 0x77, 0x05, 0xa5, 0x6b, 0x72, 0x97,
	0x95, 0xd5, 0x35, 0x26, 0xeb, 0x33, 0xd8, 0x42, 0xab, 0x49, 0xd8, 0xed, 0x83, 0xdb, 0x97, 0xfd,
	0x70, 0xc8, 0xe0, 0x98, 0xc9, 0x4f, 0x8d, 0xba, 0xc6, 0xb5, 0x68, 0x11, 0x2f, 0x19, 0x95, 0xe4,
	0x02, 0x36, 0xd0, 0x52, 0xb2, 0x54, 0x04, 0xab, 0x1a, 0xe1, 0xfe, 0xb9, 0x90, 0x7c, 0x17, 0x25,
	0x21, 0x4f, 0x67, 0x27, 0x74, 0xe3, 0xe1, 0x12, 0xae, 0xa1, 0x8b, 0xf1, 0xf0, 0x38, 0xfb, 0x36,
	0x7b, 0xbe, 0xf2, 0x60, 0x99, 0x27, 0xef, 0xd8, 0x81, 0xb1, 0x5c, 0xbd, 0x22, 0x72, 0xa8, 0xb9,
	0xcf, 0x61, 0xa1, 0x01, 0xa1, 0x7b, 0xd8, 0x75, 0xe8, 0x11, 0x8f, 0x24, 0xa0, 0x77, 0x89, 0x07,
	0xfa, 0x2c, 0x3e, 0x8b, 0x4e, 0x6f, 0x51, 0x6f, 0xab, 0x1f, 0x31, 0xd2, 0x55, 0xd2, 0xaa, 0x3c,
	0xa7, 0x63, 0xa7, 0xca, 0x9f, 0x4a, 0x04, 0x2a, 0xc1, 0x22, 0x7d, 0x4e, 0x0c, 0x72, 0x54, 0x51,
	0x43, 0xad, 0xc0, 0x09, 0x63, 0x3d, 0xd1, 0xfa, 0x57, 0xd0, 0x72, 0xfe, 0xef, 0x0f, 0xf0, 0x02,
	0x9a, 0x4b, 0x5c, 0xa5, 0xcf, 0xac, 0xbf, 0x83, 0x16, 0xc7, 0xf7, 0xc5, 0x62, 0x02, 0x42, 0x15,
	0xf9, 0xbb, 0x33, 0xe9, 0x2d, 0xf1, 0xa3, 0x32, 0x9d, 0xa7, 0xa4, 0x3e, 0xf9, 0xab, 0x33, 0xbd,
	0xb0, 0x7e, 0x0d, 0x2d, 0x64, 0xbe, 0x45, 0x71, 0xa7, 0xde, 0xa6, 0x00, 0xfa, 0x0c, 0x9e, 0x47,
	0xb3, 0xfb, 0xcc, 0xa1, 0x0c, 0xa8, 0x8c, 0xa6, 0x16, 0x25, 0x7a, 0x61, 0xfd, 0xdd, 0xa4, 0xc7,
	0xe3, 0x30, 0xf9, 0x20, 0x8c, 0x2f, 0x68, 0xf5, 0x19, 0x1e, 0x52, 0x77, 0xe2, 0x37, 0x4d, 0xc4,
	0x04, 0xcf, 0x2f, 0xbd, 0xc0, 0x39, 0x6d, 0x43, 0x00, 0x0c, 0x3c, 0xbd, 0xd8, 0x78, 0xfd, 0xc9,
	0x7f, 0xac, 0x6a, 0x4f, 0x3e, 0x5b, 0xd5, 0x7e, 0xf2, 0xd9, 0xaa, 0xf6, 0xef, 0x9f, 0xad, 0x6a,
	0x08, 0xfb, 0x24, 0xfe, 0x0d, 0x4f, 0x57, 0xde, 0x58, 0x46, 0x2d, 0xed, 0xa0, 0x22, 0xfe, 0x54,
	0xf5, 0xb5, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff, 0xc8, 0x7f, 0xda, 0x73, 0x9d, 0x35, 0x00, 0x00,
}
